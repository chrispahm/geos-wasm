// This file is automatically generated

// typedefs
/**
 * A pointer to a char * string.
 * Can be created using const ptr = geos.Module.stringToNewUTF8(someString)
 * Can be converted to JS using const str = geos.Module.UTF8ToString(ptr)
 * @typedef {number} StringPointer
 */

/**
 * A pointer to a double *, int *, or unsigned int *.
 * Can be created using const ptr = geos.Module._malloc(8)
 * Can be converted to JS using const value = geos.Module.getValue(ptr, 'double')
 * Must be freed using geos.Module._free(ptr)
 * @typedef {number} NumberPointer
 */

/**
 * A pointer to an array (double *).
 * Can be create using the following JS code:
 * const values = new Float64Array(N * dim)
 * for (let i = 0; i < values.length; i++) {
 *   values[i] = i
 * }
 * const valuesPtr = geos.Module._malloc(N * dim * 8)
 * geos.Module.HEAPF64.set(values, valuesPtr / 8)
 * Can be converted to JS using the following JS code:
 * const view = new Float64Array(geos.Module.HEAPF64.buffer, valuesPtr, N * dim * 8)
 * @typedef {number} ArrayPointer
 */

/**
* A generic pointer type.
* @typedef {(StringPointer|NumberPointer)} Pointer
*/
/**
 * Parameter object for buffering.
 * @typedef {number} GEOSBufferParams
 */

/**
 * Type returned by GEOS_init_r(), for use with the functions ending in _r (the reentrant API).
 * @typedef {number} GEOSContextHandle_t
 */

/**
 * Coordinate sequence type representing fixed-size lists of coordinates. Contains the list of vertices defining the location of a GEOSGeometry.
 * @typedef {number} GEOSCoordSequence
 */

/**
 * Callback function for use in spatial index nearest neighbor calculations. Allows custom distance to be calculated between items in the index. Is passed two items, and sets the calculated distance between the items into the distance pointer. Extra data for the calculation can be passed via the userdata.
 * This callback is displayed as a global member.
 * @callback GEOSDistanceCallback
 * @returns {number} 1 if distance calculation succeeds, 0 otherwise
 */

/**
 * Reader object to read GeoJSON format and construct a Geometry.
 * @typedef {number} GEOSGeoJSONReader
 */

/**
 * Writer object to turn a Geometry into GeoJSON.
 * @typedef {number} GEOSGeoJSONWriter
 */

/**
 * The generic type for a geometry. A geometry can be a Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, or GeometryCollection. The geometry type can be read with GEOSGeomTypeId. Most functions in GEOS have GEOSGeometry * as either a parameter or a return type.
 * @typedef {number} GEOSGeometry
 */

/**
 * Callback function for use in interruption. The callback will be invoked before checking for interruption, so can be used to request it.
 * This callback is displayed as a global member.
 * @callback GEOSInterruptCallback
 */

/**
 * Parameter object for validity enforcement.
 * @typedef {number} GEOSMakeValidParams
 */

/**
 * Callback function for passing GEOS error messages to parent process.
 * This callback is displayed as a global member.
 * @callback GEOSMessageHandler
 */

/**
 * A GEOS message handler function.
 * This callback is displayed as a global member.
 * @callback GEOSMessageHandler_r
 */

/**
 * Prepared geometry type.
 * @typedef {number} GEOSPreparedGeometry
 */

/**
 * Callback function for use in spatial index search calls. Pass into the query function and handle query results as the index returns them.
 * This callback is displayed as a global member.
 * @callback GEOSQueryCallback
 */

/**
 * STRTree index.
 * @typedef {number} GEOSSTRtree
 */

/**
 * Callback function for use in GEOSGeom_transformXY. Allows custom function to be applied to x and y values for each coordinate in a geometry. Z and M values are unchanged by this function. Extra data for the calculation can be passed via the userdata.
 * This callback is displayed as a global member.
 * @callback GEOSTransformXYCallback
 * @returns {number} 1 if calculation succeeded, 0 on failure
 */

/**
 * Reader object to read Well-Known Binary (WKB) format and construct Geometry.
 * @typedef {number} GEOSWKBReader
 */

/**
 * Writer object to turn Geometry into Well-Known Binary (WKB).
 * @typedef {number} GEOSWKBWriter
 */

/**
 * Reader object to read Well-Known Text (WKT) format and construct Geometry.
 * @typedef {number} GEOSWKTReader
 */

/**
 * Writer object to turn Geometry into Well-Known Text (WKT).
 * @typedef {number} GEOSWKTWriter
 */

export default function addGEOSFunctions (Module, geos) {
  // enums
  /**
   * Cap styles control the ends of buffered lines.
   * @see GEOSBuffer
   * @readonly
   * @alias module:geos
   * @enum {number}
   */
  geos.GEOSBufCapStyles = {
    /** End is rounded, with end point of original line in the centre of the round cap. */
    GEOSBUF_CAP_ROUND: 0,
    /** End is flat, with end point of original line at the end of the buffer */
    GEOSBUF_CAP_FLAT: 1,
    /** End is flat, with end point of original line in the middle of a square enclosing that point */
    GEOSBUF_CAP_SQUARE: 2
  }

  /**
   * Join styles control the buffer shape at bends in a line.
   * @see GEOSBuffer
   * @readonly
   * @alias module:geos
   * @enum {number}
   */
  geos.GEOSBufJoinStyles = {
    /** Join is rounded, essentially each line is terminated in a round cap. Form round corner. */
    GEOSBUF_JOIN_ROUND: 0,
    /** Join is flat, with line between buffer edges, through the join point. Forms flat corner. */
    GEOSBUF_JOIN_MITRE: 1,
    /** Join is the point at which the two buffer edges intersect. Forms sharp corner. */
    GEOSBUF_JOIN_BEVEL: 2
  }

  /**
   * Geometry type number, used by functions returning or consuming geometry types.
   * @see GEOSGeomType
   * @see GEOSGeomTypeId
   * @readonly
   * @alias module:geos
   * @enum {number}
   */
  geos.GEOSGeomTypes = {
    /** Point */
    GEOS_POINT: 0,
    /** Linestring */
    GEOS_LINESTRING: 1,
    /** Linear ring, used within polygons */
    GEOS_LINEARRING: 2,
    /** Polygon */
    GEOS_POLYGON: 3,
    /** Multipoint, a homogeneous collection of points */
    GEOS_MULTIPOINT: 4,
    /** Multilinestring, a homogeneous collection of linestrings */
    GEOS_MULTILINESTRING: 5,
    /** Multipolygon, a homogeneous collection of polygons */
    GEOS_MULTIPOLYGON: 6,
    /** Geometry collection, a heterogeneous collection of geometry */
    GEOS_GEOMETRYCOLLECTION: 7
  }

  /**
   * Algorithm to use when repairing invalid geometries.
   * @see GEOSMakeValidWithParams
   * @readonly
   * @alias module:geos
   * @enum {number}
   */
  geos.GEOSMakeValidMethods = {
    /** Original method, combines all rings into a set of noded lines and then extracts valid polygons from that linework. */
    GEOS_MAKE_VALID_LINEWORK: 0,
    /** Structured method, first makes all rings valid then merges shells and subtracts holes from shells to generate valid result. Assumes that holes and shells are correctly categorized. */
    GEOS_MAKE_VALID_STRUCTURE: 1
  }

  /**
   * Controls the behavior of the GEOSPolygonHullSimplify parameter.
   * @readonly
   * @alias module:geos
   * @enum {number}
   */
  geos.GEOSPolygonHullParameterModes = {
    /** Fraction of input vertices retained */
    GEOSHULL_PARAM_VERTEX_RATIO: 0,
    /** Ratio of simplified hull area to input area */
    GEOSHULL_PARAM_AREA_RATIO: 1
  }

  /**
   * Controls the behavior of GEOSGeom_setPrecision() when altering the precision of a geometry.
   * @readonly
   * @alias module:geos
   * @enum {number}
   */
  geos.GEOSPrecisionRules = {
    /** The output is always valid. Collapsed geometry elements (including both polygons and lines) are removed. */
    GEOS_PREC_VALID_OUTPUT: 0,
    /** Precision reduction is performed pointwise. Output geometry may be invalid due to collapse or self-intersection. (This might be better called "GEOS_PREC_POINTWISE" - the current name is historical.) */
    GEOS_PREC_NO_TOPO: 1,
    /** Like the default mode, except that collapsed linear geometry elements are preserved. Collapsed polygonal input elements are removed. */
    GEOS_PREC_KEEP_COLLAPSED: 2
  }

  /**
   * Controls the behavior of the result of GEOSRelate when returning DE9IM results for two geometries.
   * @readonly
   * @alias module:geos
   * @enum {number}
   */
  geos.GEOSRelateBoundaryNodeRules = {
    /** See geos::algorithm::BoundaryNodeRule::getBoundaryRuleMod2() */
    GEOSRELATE_BNR_MOD2: 0,
    /** Same as GEOSRELATE_BNR_MOD2 */
    GEOSRELATE_BNR_OGC: 1,
    /** See geos::algorithm::BoundaryNodeRule::getBoundaryEndPoint() */
    GEOSRELATE_BNR_ENDPOINT: 2,
    /** See geos::algorithm::BoundaryNodeRule::getBoundaryMultivalentEndPoint() */
    GEOSRELATE_BNR_MULTIVALENT_ENDPOINT: 3,
    /** See geos::algorithm::BoundaryNodeRule::getBoundaryMonovalentEndPoint() */
    GEOSRELATE_BNR_MONOVALENT_ENDPOINT: 4
  }

  /**
   * Change behaviour of validity testing in GEOSisValidDetail
   * @readonly
   * @alias module:geos
   * @enum {number}
   */
  geos.GEOSValidFlags = {
    /** Allow self-touching rings to form a hole in a polygon. */
    GEOSVALID_ALLOW_SELFTOUCHING_RING_FORMING_HOLE: 0
  }

  /**
   * Change behaviour of GEOSVoronoiDiagram
   * @readonly
   * @alias module:geos
   * @enum {number}
   */
  geos.GEOSVoronoiFlags = {
    /** Return only edges of the Voronoi cells, as a MultiLineString */
    GEOS_VORONOI_ONLY_EDGES: 0,
    /** Preserve order of inputs, such that the nth cell in the result corresponds to the nth vertex in the input. If this cannot be done, such as for inputs that contain repeated points, GEOSVoronoiDiagram will return NULL. */
    GEOS_VORONOI_PRESERVE_ORDER: 1
  }

  /**
   * Well-known binary byte orders used when writing to WKB.
   * @see GEOSWKBWriter_setByteOrder
   * @readonly
   * @alias module:geos
   * @enum {number}
   */
  geos.GEOSWKBByteOrders = {
    /** Big Endian */
    GEOS_WKB_XDR: 0,
    /** Little Endian */
    GEOS_WKB_NDR: 1
  }

  /**
   * Well-known binary flavors to use when writing to WKB. ISO flavour is more standard. Extended flavour supports 3D and SRID embedding. GEOS reads both transparently.
   * @see GEOSWKBWriter_setFlavor
   * @readonly
   * @alias module:geos
   * @enum {number}
   */
  geos.GEOSWKBFlavors = {
    /** Extended */
    GEOS_WKB_EXTENDED: 0,
    /** ISO */
    GEOS_WKB_ISO: 1
  }

  // functions
  /**
   * For non-reentrant code, call when all GEOS operations are complete, cleans up global resources.
   * @returns {null} void
   * @alias module:geos
   */
  geos.finishGEOS = null

  /**
   * @param {GEOSContextHandle_t} handle -
   * @returns {null} void
   * @deprecated in 3.5.0, replaced by GEOS_finish_r()
   * @alias module:geos
   */
  geos.finishGEOS_r = Module.cwrap('finishGEOS_r', 'null', ['number'])

  /**
   * Free the memory associated with a GEOSContextHandle_t when you are finished calling GEOS functions.
   * @param {GEOSContextHandle_t} handle - to be freed
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOS_finish_r = Module.cwrap('GEOS_finish_r', 'null', ['number'])

  /**
   * @returns {number} int
   * @deprecated use GEOSWKBWriter and GEOSWKBWriter_getByteOrder()
   * @alias module:geos
   */
  geos.GEOS_getWKBByteOrder = null

  /**
   * @param {GEOSContextHandle_t} handle -
   * @returns {number} int
   * @deprecated use GEOSWKBWriter and GEOSWKBWriter_getByteOrder_r()
   * @alias module:geos
   */
  geos.GEOS_getWKBByteOrder_r = Module.cwrap('GEOS_getWKBByteOrder_r', 'number', ['number'])

  /**
   * @returns {number} int
   * @deprecated use GEOSWKBWriter and GEOS_getWKBOutputDims()
   * @alias module:geos
   */
  geos.GEOS_getWKBOutputDims = null

  /**
   * @param {GEOSContextHandle_t} handle -
   * @returns {number} int
   * @deprecated use GEOSWKBWriter and GEOSWKBWriter_getOutputDimension_r()
   * @alias module:geos
   */
  geos.GEOS_getWKBOutputDims_r = Module.cwrap('GEOS_getWKBOutputDims_r', 'number', ['number'])

  /**
   * Allocate and initialize a context. Pass this context as the first argument when calling other *_r functions. Contexts must only be used from a single thread at a time.
   * @returns {GEOSContextHandle_t} a new GEOS context.
   * @alias module:geos
   */
  geos.GEOS_init_r = Module.cwrap('GEOS_init_r', 'number', [])

  /**
   * Cancel a pending interruption request
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOS_interruptCancel = null

  /**
   * Register a function to be called when processing is interrupted.
   * @param {GEOSInterruptCallback} cb - Callback function to invoke
   * @returns {GEOSInterruptCallback} the previously configured callback
   * @alias module:geos
   */
  geos.GEOS_interruptRegisterCallback = null

  /**
   * Request safe interruption of operations
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOS_interruptRequest = null

  /**
   * Print the shortest representation of a double. Non-zero absolute values that are <1e-4 and >=1e+17 are formatted using scientific notation, and other values are formatted with positional notation with precision used for the max digits after decimal point.
   * @param {number} d - The number to format.
   * @param {number} precision - The desired precision.
   * @param {StringPointer} result - The buffer to write the result to, with a suggested size 28.
   * @returns {number} the length of the written string.
   * @alias module:geos
   */
  geos.GEOS_printDouble = null

  /**
   * @param {number} byteOrder -
   * @returns {number} int
   * @deprecated use GEOSWKBWriter and GEOSWKBWriter_setByteOrder()
   * @alias module:geos
   */
  geos.GEOS_setWKBByteOrder = null

  /**
   * @param {GEOSContextHandle_t} handle -
   * @param {number} byteOrder -
   * @returns {number} int
   * @deprecated use GEOSWKBWriter and GEOSWKBWriter_setByteOrder_r()
   * @alias module:geos
   */
  geos.GEOS_setWKBByteOrder_r = Module.cwrap('GEOS_setWKBByteOrder_r', 'number', ['number', 'number'])

  /**
   * @param {number} newDims -
   * @returns {number} int
   * @deprecated use GEOSWKBWriter and GEOS_setWKBOutputDims()
   * @alias module:geos
   */
  geos.GEOS_setWKBOutputDims = null

  /**
   * @param {GEOSContextHandle_t} handle -
   * @param {number} newDims -
   * @returns {number} int
   * @deprecated use GEOSWKBWriter and GEOSWKBWriter_setOutputDimension_r()
   * @alias module:geos
   */
  geos.GEOS_setWKBOutputDims_r = Module.cwrap('GEOS_setWKBOutputDims_r', 'number', ['number', 'number'])

  /**
   * Calculate the area of a geometry.
   * @param {GEOSGeometry} g - Input geometry
   * @param {NumberPointer} area - Pointer to be filled in with area result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSArea = null

  /**
   * Calculate the area of a geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @param {NumberPointer} area - Pointer to be filled in with area result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSArea_r = Module.cwrap('GEOSArea_r', 'number', ['number', 'number', 'number'])

  /**
   * Returns the "boundary" of a geometry, as defined by the DE9IM:
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} A newly allocated geometry of the boundary. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSBoundary = null

  /**
   * Returns the "boundary" of a geometry, as defined by the DE9IM:
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} A newly allocated geometry of the boundary. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSBoundary_r = Module.cwrap('GEOSBoundary_r', 'number', ['number', 'number'])

  /**
   * Buffer a geometry.
   * @param {GEOSGeometry} g - The input geometry to be buffered.
   * @param {number} width - The distance by which to expand the geometry (or contract) if the value is negative.
   * @param {number} quadsegs - The number of segments per quadrant to generate. More segments provides a more "precise" buffer at the expense of size.
   * @returns {GEOSGeometry} A GEOSGeometry of the buffered result. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSBuffer = null

  /**
   * Buffer a geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry to be buffered.
   * @param {number} width - The distance by which to expand the geometry (or contract) if the value is negative.
   * @param {number} quadsegs - The number of segments per quadrant to generate. More segments provides a more "precise" buffer at the expense of size.
   * @returns {GEOSGeometry} A GEOSGeometry of the buffered result. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSBuffer_r = Module.cwrap('GEOSBuffer_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Create a default GEOSBufferParams object for controlling the shape of buffered generated by GEOSBuffer.
   * @returns {GEOSBufferParams} A newly allocated GEOSBufferParams. NULL on exception. Caller is responsible for freeing with GEOSBufferParams_destroy().
   * @alias module:geos
   */
  geos.GEOSBufferParams_create = null

  /**
   * Create a default GEOSBufferParams object for controlling the shape of buffered generated by GEOSBuffer.
   * @param {GEOSContextHandle_t} handle -
   * @returns {GEOSBufferParams} A newly allocated GEOSBufferParams. NULL on exception. Caller is responsible for freeing with GEOSBufferParams_destroy().
   * @alias module:geos
   */
  geos.GEOSBufferParams_create_r = Module.cwrap('GEOSBufferParams_create_r', 'number', ['number'])

  /**
   * Destroy a GEOSBufferParams and free all associated memory.
   * @param {GEOSBufferParams} parms - The object to destroy.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSBufferParams_destroy = null

  /**
   * Destroy a GEOSBufferParams and free all associated memory.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSBufferParams} parms - The object to destroy.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSBufferParams_destroy_r = Module.cwrap('GEOSBufferParams_destroy_r', 'null', ['number', 'number'])

  /**
   * Set the end cap type of a GEOSBufferParams to the desired style, which must be one enumerated in GEOSBufCapStyles.
   * @param {GEOSBufferParams} p -
   * @param {number} style -
   * @returns {number} 0 on exception, 1 on success.
   * @alias module:geos
   */
  geos.GEOSBufferParams_setEndCapStyle = null

  /**
   * Set the end cap type of a GEOSBufferParams to the desired style, which must be one enumerated in GEOSBufCapStyles.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSBufferParams} p -
   * @param {number} style -
   * @returns {number} 0 on exception, 1 on success.
   * @alias module:geos
   */
  geos.GEOSBufferParams_setEndCapStyle_r = Module.cwrap('GEOSBufferParams_setEndCapStyle_r', 'number', ['number', 'number', 'number'])

  /**
   * Set the join type of a GEOSBufferParams to the desired style, which must be one enumerated in GEOSBufJoinStyles.
   * @param {GEOSBufferParams} p -
   * @param {number} joinStyle -
   * @returns {number} 0 on exception, 1 on success.
   * @alias module:geos
   */
  geos.GEOSBufferParams_setJoinStyle = null

  /**
   * Set the join type of a GEOSBufferParams to the desired style, which must be one enumerated in GEOSBufJoinStyles.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSBufferParams} p -
   * @param {number} joinStyle -
   * @returns {number} 0 on exception, 1 on success.
   * @alias module:geos
   */
  geos.GEOSBufferParams_setJoinStyle_r = Module.cwrap('GEOSBufferParams_setJoinStyle_r', 'number', ['number', 'number', 'number'])

  /**
   * Set the mitre limit of a GEOSBufferParams to the desired size. For acute angles, a mitre join can extend very very far from the input geometry, which is probably not desired. The mitre limit places an upper bound on that.
   * @param {GEOSBufferParams} p - The GEOSBufferParams to operate on
   * @param {number} mitreLimit - The limit to set
   * @returns {number} 0 on exception, 1 on success.
   * @alias module:geos
   */
  geos.GEOSBufferParams_setMitreLimit = null

  /**
   * Set the mitre limit of a GEOSBufferParams to the desired size. For acute angles, a mitre join can extend very very far from the input geometry, which is probably not desired. The mitre limit places an upper bound on that.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSBufferParams} p - The GEOSBufferParams to operate on
   * @param {number} mitreLimit - The limit to set
   * @returns {number} 0 on exception, 1 on success.
   * @alias module:geos
   */
  geos.GEOSBufferParams_setMitreLimit_r = Module.cwrap('GEOSBufferParams_setMitreLimit_r', 'number', ['number', 'number', 'number'])

  /**
   * Set the number of segments to use to stroke each quadrant of circular arcs generated by the buffering process. More segments means a smoother output, but with larger size.
   * @param {GEOSBufferParams} p - The GEOSBufferParams to operate on
   * @param {number} quadSegs - Number of segments per quadrant
   * @returns {number} 0 on exception, 1 on success.
   * @alias module:geos
   */
  geos.GEOSBufferParams_setQuadrantSegments = null

  /**
   * Set the number of segments to use to stroke each quadrant of circular arcs generated by the buffering process. More segments means a smoother output, but with larger size.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSBufferParams} p - The GEOSBufferParams to operate on
   * @param {number} quadSegs - Number of segments per quadrant
   * @returns {number} 0 on exception, 1 on success.
   * @alias module:geos
   */
  geos.GEOSBufferParams_setQuadrantSegments_r = Module.cwrap('GEOSBufferParams_setQuadrantSegments_r', 'number', ['number', 'number', 'number'])

  /**
   * Sets whether the computed buffer should be single-sided. A single-sided buffer is constructed on only one side of each input line.
   * @param {GEOSBufferParams} p - The GEOSBufferParams to operate on
   * @param {number} singleSided - Set to 1 for single-sided output 0 otherwise
   * @returns {number} 0 on exception, 1 on success.
   * @alias module:geos
   */
  geos.GEOSBufferParams_setSingleSided = null

  /**
   * Sets whether the computed buffer should be single-sided. A single-sided buffer is constructed on only one side of each input line.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSBufferParams} p - The GEOSBufferParams to operate on
   * @param {number} singleSided - Set to 1 for single-sided output 0 otherwise
   * @returns {number} 0 on exception, 1 on success.
   * @alias module:geos
   */
  geos.GEOSBufferParams_setSingleSided_r = Module.cwrap('GEOSBufferParams_setSingleSided_r', 'number', ['number', 'number', 'number'])

  /**
   * Generates a buffer using the special parameters in the GEOSBufferParams
   * @param {GEOSGeometry} g - The geometry to buffer
   * @param {GEOSBufferParams} p - The parameters to apply to the buffer process
   * @param {number} width - The buffer distance
   * @returns {GEOSGeometry} The buffered geometry, or NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSBufferWithParams = null

  /**
   * Generates a buffer using the special parameters in the GEOSBufferParams
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The geometry to buffer
   * @param {GEOSBufferParams} p - The parameters to apply to the buffer process
   * @param {number} width - The buffer distance
   * @returns {GEOSGeometry} The buffered geometry, or NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSBufferWithParams_r = Module.cwrap('GEOSBufferWithParams_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Generate a buffer using the provided style parameters.
   * @param {GEOSGeometry} g - The geometry to buffer
   * @param {number} width - Width of the buffer
   * @param {number} quadsegs - Number of segments per quadrant
   * @param {number} endCapStyle - See GEOSBufCapStyles
   * @param {number} joinStyle - See GEOSBufJoinStyles
   * @param {number} mitreLimit - See GEOSBufferParams_setMitreLimit
   * @returns {GEOSGeometry} The buffered geometry, or NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSBufferWithStyle = null

  /**
   * Generate a buffer using the provided style parameters.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The geometry to buffer
   * @param {number} width - Width of the buffer
   * @param {number} quadsegs - Number of segments per quadrant
   * @param {number} endCapStyle - See GEOSBufCapStyles
   * @param {number} joinStyle - See GEOSBufJoinStyles
   * @param {number} mitreLimit - See GEOSBufferParams_setMitreLimit
   * @returns {GEOSGeometry} The buffered geometry, or NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSBufferWithStyle_r = Module.cwrap('GEOSBufferWithStyle_r', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number'])

  /**
   * Perform a polygonization using all the linework, assuming that rings contained within rings are empty holes, rather then extra polygons.
   * @param {GEOSGeometry} g - The input linework
   * @returns {GEOSGeometry} The polygonal output Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSBuildArea = null

  /**
   * Perform a polygonization using all the linework, assuming that rings contained within rings are empty holes, rather then extra polygons.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input linework
   * @returns {GEOSGeometry} The polygonal output Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSBuildArea_r = Module.cwrap('GEOSBuildArea_r', 'number', ['number', 'number'])

  /**
   * Intersection optimized for a rectangular clipping polygon. Supposed to be faster than using GEOSIntersection(). Not guaranteed to return valid results.
   * @param {GEOSGeometry} g - The input geometry to be clipped
   * @param {number} xmin - Left bound of clipping rectangle
   * @param {number} ymin - Lower bound of clipping rectangle
   * @param {number} xmax - Right bound of clipping rectangle
   * @param {number} ymax - Upper bound of clipping rectangle
   * @returns {GEOSGeometry} The clipped geometry or NULL on exception Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSClipByRect = null

  /**
   * Intersection optimized for a rectangular clipping polygon. Supposed to be faster than using GEOSIntersection(). Not guaranteed to return valid results.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry to be clipped
   * @param {number} xmin - Left bound of clipping rectangle
   * @param {number} ymin - Lower bound of clipping rectangle
   * @param {number} xmax - Right bound of clipping rectangle
   * @param {number} ymax - Upper bound of clipping rectangle
   * @returns {GEOSGeometry} The clipped geometry or NULL on exception Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSClipByRect_r = Module.cwrap('GEOSClipByRect_r', 'number', ['number', 'number', 'number', 'number', 'number', 'number'])

  /**
   * Returns a "concave hull" of a geometry. A concave hull is a polygon which contains all the points of the input, but is a better approximation than the convex hull to the area occupied by the input. Frequently used to convert a multi-point into a polygonal area. that contains all the points in the input Geometry.
   * @param {GEOSGeometry} g - The input geometry
   * @param {number} ratio - The edge length ratio value, between 0 and 1.
   * @param {number} allowHoles - When non-zero, the polygonal output may contain holes.
   * @returns {GEOSGeometry} A newly allocated geometry of the concave hull. NULL on exception.
   * @alias module:geos
   */
  geos.GEOSConcaveHull = null

  /**
   * Returns a "concave hull" of a geometry. A concave hull is a polygon which contains all the points of the input, but is a better approximation than the convex hull to the area occupied by the input. Frequently used to convert a multi-point into a polygonal area. that contains all the points in the input Geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry
   * @param {number} ratio - The edge length ratio value, between 0 and 1.
   * @param {number} allowHoles - When non-zero, the polygonal output may contain holes.
   * @returns {GEOSGeometry} A newly allocated geometry of the concave hull. NULL on exception.
   * @alias module:geos
   */
  geos.GEOSConcaveHull_r = Module.cwrap('GEOSConcaveHull_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Returns a "concave hull" of a geometry. A concave hull is a polygon which contains all the points of the input, but is a better approximation than the convex hull to the area occupied by the input. Frequently used to convert a multi-point into a polygonal area. that contains all the points in the input Geometry.
   * @param {GEOSGeometry} g - The input geometry
   * @param {number} length - The maximum edge length (0 or greater)
   * @param {number} allowHoles - When non-zero, the polygonal output may contain holes.
   * @returns {GEOSGeometry} A newly allocated geometry of the concave hull. NULL on exception.
   * @alias module:geos
   */
  geos.GEOSConcaveHullByLength = null

  /**
   * Returns a "concave hull" of a geometry. A concave hull is a polygon which contains all the points of the input, but is a better approximation than the convex hull to the area occupied by the input. Frequently used to convert a multi-point into a polygonal area. that contains all the points in the input Geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry
   * @param {number} ratio - The maximum edge length (0 or greater)
   * @param {number} allowHoles - When non-zero, the polygonal output may contain holes.
   * @returns {GEOSGeometry} A newly allocated geometry of the concave hull. NULL on exception.
   * @alias module:geos
   */
  geos.GEOSConcaveHullByLength_r = Module.cwrap('GEOSConcaveHullByLength_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Constructs a concave hull of a set of polygons, respecting the polygons as constraints.
   * @param {GEOSGeometry} g - the valid MultiPolygon geometry to process
   * @param {number} lengthRatio - specifies the Maximum Edge Length as a fraction of the difference between the longest and shortest edge lengths between the polygons. This normalizes the Maximum Edge Length to be scale-free. A value of 1 produces the convex hull; a value of 0 produces the original polygons.
   * @param {number} isTight - is the concave hull allowed to contain holes?
   * @param {number} isHolesAllowed - does the hull follow the outer boundaries of the input polygons.
   * @returns {GEOSGeometry} A newly allocated geometry of the concave hull. NULL on exception.
   * @alias module:geos
   */
  geos.GEOSConcaveHullOfPolygons = null

  /**
   * Constructs a concave hull of a set of polygons, respecting the polygons as constraints.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - the valid MultiPolygon geometry to process
   * @param {number} lengthRatio - specifies the Maximum Edge Length as a fraction of the difference between the longest and shortest edge lengths between the polygons. This normalizes the Maximum Edge Length to be scale-free. A value of 1 produces the convex hull; a value of 0 produces the original polygons.
   * @param {number} isTight - is the concave hull allowed to contain holes?
   * @param {number} isHolesAllowed - does the hull follow the outer boundaries of the input polygons.
   * @returns {GEOSGeometry} A newly allocated geometry of the concave hull. NULL on exception.
   * @alias module:geos
   */
  geos.GEOSConcaveHullOfPolygons_r = Module.cwrap('GEOSConcaveHullOfPolygons_r', 'number', ['number', 'number', 'number', 'number', 'number'])

  /**
   * Return a constrained Delaunay triangulation of the vertices of the given polygon(s). For non-polygonal inputs, returns an empty geometry collection.
   * @param {GEOSGeometry} g - the input geometry whose rings will be used as input
   * @returns {GEOSGeometry} A newly allocated geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSConstrainedDelaunayTriangulation = null

  /**
   * Return a constrained Delaunay triangulation of the vertices of the given polygon(s). For non-polygonal inputs, returns an empty geometry collection.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - the input geometry whose rings will be used as input
   * @returns {GEOSGeometry} A newly allocated geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSConstrainedDelaunayTriangulation_r = Module.cwrap('GEOSConstrainedDelaunayTriangulation_r', 'number', ['number', 'number'])

  /**
   * Tests if geometry g2 is completely within g1, but not wholly contained in the boundary of g1.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSContains = null

  /**
   * Tests if geometry g2 is completely within g1, but not wholly contained in the boundary of g1.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSContains_r = Module.cwrap('GEOSContains_r', 'number', ['number', 'number', 'number'])

  /**
   * Set the notice handler callback function for run-time error messages.
   * @param {GEOSContextHandle_t} extHandle - the GEOS context from GEOS_init_r
   * @param {GEOSMessageHandler} ef - the handler callback
   * @returns {GEOSMessageHandler} the previously configured message handler or NULL if no message handler was configured
   * @alias module:geos
   */
  geos.GEOSContext_setErrorHandler_r = Module.cwrap('GEOSContext_setErrorHandler_r', 'number', ['number', 'number'])

  /**
   * Sets an error message handler on the given GEOS context.
   * @param {GEOSContextHandle_t} extHandle - the GEOS context
   * @param {GEOSMessageHandler_r} ef - the message handler
   * @param {Pointer} userData - optional user data pointer that will be passed to the message handler
   * @returns {GEOSMessageHandler_r} the previously configured message handler or NULL if no message handler was configured
   * @alias module:geos
   */
  geos.GEOSContext_setErrorMessageHandler_r = Module.cwrap('GEOSContext_setErrorMessageHandler_r', 'number', ['number', 'number', 'number'])

  /**
   * Set the notice handler callback function for run-time notice messages.
   * @param {GEOSContextHandle_t} extHandle - the context returned by GEOS_init_r.
   * @param {GEOSMessageHandler} nf - the handler callback
   * @returns {GEOSMessageHandler} the previously configured message handler or NULL if no message handler was configured
   * @alias module:geos
   */
  geos.GEOSContext_setNoticeHandler_r = Module.cwrap('GEOSContext_setNoticeHandler_r', 'number', ['number', 'number'])

  /**
   * Sets a notice message handler on the given GEOS context.
   * @param {GEOSContextHandle_t} extHandle - the GEOS context from GEOS_init_r
   * @param {GEOSMessageHandler_r} nf - the message handler
   * @param {Pointer} userData - optional user data pointer that will be passed to the message handler
   * @returns {GEOSMessageHandler_r} the previously configured message handler or NULL if no message handler was configured
   * @alias module:geos
   */
  geos.GEOSContext_setNoticeMessageHandler_r = Module.cwrap('GEOSContext_setNoticeMessageHandler_r', 'number', ['number', 'number', 'number'])

  /**
   * Returns convex hull of a geometry. The smallest convex Geometry that contains all the points in the input Geometry
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} A newly allocated geometry of the convex hull. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSConvexHull = null

  /**
   * Returns convex hull of a geometry. The smallest convex Geometry that contains all the points in the input Geometry
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} A newly allocated geometry of the convex hull. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSConvexHull_r = Module.cwrap('GEOSConvexHull_r', 'number', ['number', 'number'])

  /**
   * Clone a coordinate sequence.
   * @param {GEOSCoordSequence} s - the coordinate sequence to clone
   * @returns {GEOSCoordSequence} a copy of the coordinate sequence or NULL on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_clone = null

  /**
   * Clone a coordinate sequence.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - the coordinate sequence to clone
   * @returns {GEOSCoordSequence} a copy of the coordinate sequence or NULL on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_clone_r = Module.cwrap('GEOSCoordSeq_clone_r', 'number', ['number', 'number'])

  /**
   * Create a coordinate sequence by copying from arrays of doubles
   * @param {ArrayPointer} x - array of x coordinates
   * @param {ArrayPointer} y - array of y coordinates
   * @param {ArrayPointer} z - array of z coordinates, or NULL
   * @param {ArrayPointer} m - array of m coordinates, or NULL
   * @param {number} size - length of each array
   * @returns {GEOSCoordSequence} the sequence or NULL on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_copyFromArrays = null

  /**
   * Create a coordinate sequence by copying from arrays of doubles
   * @param {GEOSContextHandle_t} handle -
   * @param {ArrayPointer} x - array of x coordinates
   * @param {ArrayPointer} y - array of y coordinates
   * @param {ArrayPointer} z - array of z coordinates, or NULL
   * @param {ArrayPointer} m - array of m coordinates, or NULL
   * @param {number} size - length of each array
   * @returns {GEOSCoordSequence} the sequence or NULL on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_copyFromArrays_r = Module.cwrap('GEOSCoordSeq_copyFromArrays_r', 'number', ['number', 'number', 'number', 'number', 'number', 'number'])

  /**
   * Create a coordinate sequence by copying from an interleaved buffer of doubles (e.g., XYXY or XYZXYZ)
   * @param {NumberPointer} buf - pointer to buffer
   * @param {number} size - number of coordinates in the sequence
   * @param {number} hasZ - does buffer have Z values?
   * @param {number} hasM - does buffer have M values?
   * @returns {GEOSCoordSequence} the sequence or NULL on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_copyFromBuffer = null

  /**
   * Create a coordinate sequence by copying from an interleaved buffer of doubles (e.g., XYXY or XYZXYZ)
   * @param {GEOSContextHandle_t} handle -
   * @param {NumberPointer} buf - pointer to buffer
   * @param {number} size - number of coordinates in the sequence
   * @param {number} hasZ - does buffer have Z values?
   * @param {number} hasM - does buffer have M values?
   * @returns {GEOSCoordSequence} the sequence or NULL on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_copyFromBuffer_r = Module.cwrap('GEOSCoordSeq_copyFromBuffer_r', 'number', ['number', 'number', 'number', 'number', 'number'])

  /**
   * Copy the contents of a coordinate sequence to arrays of doubles
   * @param {GEOSCoordSequence} s - sequence to copy
   * @param {ArrayPointer} x - array to which x values should be copied
   * @param {ArrayPointer} y - array to which y values should be copied
   * @param {ArrayPointer} z - array to which z values should be copied, or NULL
   * @param {ArrayPointer} m - array to which m values should be copied, or NULL
   * @returns {number} 1 on success, 0 on error
   * @alias module:geos
   */
  geos.GEOSCoordSeq_copyToArrays = null

  /**
   * Copy the contents of a coordinate sequence to arrays of doubles
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - sequence to copy
   * @param {ArrayPointer} x - array to which x values should be copied
   * @param {ArrayPointer} y - array to which y values should be copied
   * @param {ArrayPointer} z - array to which z values should be copied, or NULL
   * @param {ArrayPointer} m - array to which m values should be copied, or NULL
   * @returns {number} 1 on success, 0 on error
   * @alias module:geos
   */
  geos.GEOSCoordSeq_copyToArrays_r = Module.cwrap('GEOSCoordSeq_copyToArrays_r', 'number', ['number', 'number', 'number', 'number', 'number', 'number'])

  /**
   * Copy the contents of a coordinate sequence to an interleaved buffer of doubles (e.g., XYXY or XYZXYZ)
   * @param {GEOSCoordSequence} s - sequence to copy
   * @param {NumberPointer} buf - buffer to which coordinates should be copied
   * @param {number} hasZ - copy Z values to buffer?
   * @param {number} hasM - copy M values to buffer?
   * @returns {number} 1 on success, 0 on error
   * @alias module:geos
   */
  geos.GEOSCoordSeq_copyToBuffer = null

  /**
   * Copy the contents of a coordinate sequence to an interleaved buffer of doubles (e.g., XYXY or XYZXYZ)
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - sequence to copy
   * @param {NumberPointer} buf - buffer to which coordinates should be copied
   * @param {number} hasZ - copy Z values to buffer?
   * @param {number} hasM - copy M values to buffer?
   * @returns {number} 1 on success, 0 on error
   * @alias module:geos
   */
  geos.GEOSCoordSeq_copyToBuffer_r = Module.cwrap('GEOSCoordSeq_copyToBuffer_r', 'number', ['number', 'number', 'number', 'number', 'number'])

  /**
   * Create a coordinate sequence.
   * @param {number} size - number of coordinates in the sequence
   * @param {number} dims - dimensionality of the coordinates (2, 3 or 4)
   * @returns {GEOSCoordSequence} the sequence or NULL on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_create = null

  /**
   * Create a coordinate sequence.
   * @param {GEOSContextHandle_t} handle -
   * @param {number} size - number of coordinates in the sequence
   * @param {number} dims - dimensionality of the coordinates (2, 3 or 4)
   * @returns {GEOSCoordSequence} the sequence or NULL on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_create_r = Module.cwrap('GEOSCoordSeq_create_r', 'number', ['number', 'number', 'number'])

  /**
   * Destroy a coordinate sequence, freeing all memory.
   * @param {GEOSCoordSequence} s - the coordinate sequence to destroy
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSCoordSeq_destroy = null

  /**
   * Destroy a coordinate sequence, freeing all memory.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - the coordinate sequence to destroy
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSCoordSeq_destroy_r = Module.cwrap('GEOSCoordSeq_destroy_r', 'null', ['number', 'number'])

  /**
   * Get dimension info from a coordinate sequence.
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {NumberPointer} dims - pointer where dimension value will be placed
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_getDimensions = null

  /**
   * Get dimension info from a coordinate sequence.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {NumberPointer} dims - pointer where dimension value will be placed
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_getDimensions_r = Module.cwrap('GEOSCoordSeq_getDimensions_r', 'number', ['number', 'number', 'number'])

  /**
   * Read Nth ordinate value from a coordinate sequence.
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {number} dim - the dimension number of the ordinate to read, zero based
   * @param {NumberPointer} val - pointer where ordinate value will be placed
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_getOrdinate = null

  /**
   * Read Nth ordinate value from a coordinate sequence.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {number} dim - the dimension number of the ordinate to read, zero based
   * @param {NumberPointer} val - pointer where ordinate value will be placed
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_getOrdinate_r = Module.cwrap('GEOSCoordSeq_getOrdinate_r', 'number', ['number', 'number', 'number', 'number', 'number'])

  /**
   * Get size info from a coordinate sequence.
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {NumberPointer} size - pointer where size value will be placed
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_getSize = null

  /**
   * Get size info from a coordinate sequence.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {NumberPointer} size - pointer where size value will be placed
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_getSize_r = Module.cwrap('GEOSCoordSeq_getSize_r', 'number', ['number', 'number', 'number'])

  /**
   * Read X ordinate values from a coordinate sequence.
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {NumberPointer} val - pointer where ordinate value will be placed
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_getX = null

  /**
   * Read X ordinate values from a coordinate sequence.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {NumberPointer} val - pointer where ordinate value will be placed
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_getX_r = Module.cwrap('GEOSCoordSeq_getX_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Read X and Y ordinate values from a coordinate sequence.
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {NumberPointer} x - pointer where ordinate X value will be placed
   * @param {NumberPointer} y - pointer where ordinate Y value will be placed
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_getXY = null

  /**
   * Read X and Y ordinate values from a coordinate sequence.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {NumberPointer} x - pointer where ordinate X value will be placed
   * @param {NumberPointer} y - pointer where ordinate Y value will be placed
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_getXY_r = Module.cwrap('GEOSCoordSeq_getXY_r', 'number', ['number', 'number', 'number', 'number', 'number'])

  /**
   * Read X and Y ordinate values from a coordinate sequence.
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {NumberPointer} x - pointer where ordinate X value will be placed
   * @param {NumberPointer} y - pointer where ordinate Y value will be placed
   * @param {NumberPointer} z - pointer where ordinate Z value will be placed
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_getXYZ = null

  /**
   * Read X and Y ordinate values from a coordinate sequence.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {NumberPointer} x - pointer where ordinate X value will be placed
   * @param {NumberPointer} y - pointer where ordinate Y value will be placed
   * @param {NumberPointer} z - pointer where ordinate Z value will be placed
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_getXYZ_r = Module.cwrap('GEOSCoordSeq_getXYZ_r', 'number', ['number', 'number', 'number', 'number', 'number', 'number'])

  /**
   * Read Y ordinate values from a coordinate sequence.
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {NumberPointer} val - pointer where ordinate value will be placed
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_getY = null

  /**
   * Read Y ordinate values from a coordinate sequence.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {NumberPointer} val - pointer where ordinate value will be placed
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_getY_r = Module.cwrap('GEOSCoordSeq_getY_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Read Z ordinate values from a coordinate sequence.
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {NumberPointer} val - pointer where ordinate value will be placed
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_getZ = null

  /**
   * Read Z ordinate values from a coordinate sequence.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {NumberPointer} val - pointer where ordinate value will be placed
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_getZ_r = Module.cwrap('GEOSCoordSeq_getZ_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Check orientation of a coordinate sequence. Closure of the sequence is assumed. Invalid (collapsed) or short (fewer than 4 points) sequences return false.
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {StringPointer} is_ccw - pointer for ccw value, 1 if counter-clockwise orientation, 0 otherwise
   * @returns {number} 0 on exception, 1 on success
   * @alias module:geos
   */
  geos.GEOSCoordSeq_isCCW = null

  /**
   * Check orientation of a coordinate sequence. Closure of the sequence is assumed. Invalid (collapsed) or short (fewer than 4 points) sequences return false.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {StringPointer} is_ccw - pointer for ccw value, 1 if counter-clockwise orientation, 0 otherwise
   * @returns {number} 0 on exception, 1 on success
   * @alias module:geos
   */
  geos.GEOSCoordSeq_isCCW_r = Module.cwrap('GEOSCoordSeq_isCCW_r', 'number', ['number', 'number', 'number'])

  /**
   * Set Nth ordinate value in a coordinate sequence.
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {number} dim - the dimension number of the ordinate to alter, zero based
   * @param {number} val - the value to set the ordinate to
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_setOrdinate = null

  /**
   * Set Nth ordinate value in a coordinate sequence.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {number} dim - the dimension number of the ordinate to alter, zero based
   * @param {number} val - the value to set the ordinate to
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_setOrdinate_r = Module.cwrap('GEOSCoordSeq_setOrdinate_r', 'number', ['number', 'number', 'number', 'number', 'number'])

  /**
   * Set X ordinate values in a coordinate sequence.
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {number} val - the value to set the ordinate to
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_setX = null

  /**
   * Set X ordinate values in a coordinate sequence.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {number} val - the value to set the ordinate to
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_setX_r = Module.cwrap('GEOSCoordSeq_setX_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Set X and Y ordinate values in a coordinate sequence simultaneously.
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {number} x - the value to set the X ordinate to
   * @param {number} y - the value to set the Y ordinate to
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_setXY = null

  /**
   * Set X and Y ordinate values in a coordinate sequence simultaneously.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {number} x - the value to set the X ordinate to
   * @param {number} y - the value to set the Y ordinate to
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_setXY_r = Module.cwrap('GEOSCoordSeq_setXY_r', 'number', ['number', 'number', 'number', 'number', 'number'])

  /**
   * Set X, Y and Z ordinate values in a coordinate sequence simultaneously.
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {number} x - the value to set the X ordinate to
   * @param {number} y - the value to set the Y ordinate to
   * @param {number} z - the value to set the Z ordinate to
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_setXYZ = null

  /**
   * Set X, Y and Z ordinate values in a coordinate sequence simultaneously.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {number} x - the value to set the X ordinate to
   * @param {number} y - the value to set the Y ordinate to
   * @param {number} z - the value to set the Z ordinate to
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_setXYZ_r = Module.cwrap('GEOSCoordSeq_setXYZ_r', 'number', ['number', 'number', 'number', 'number', 'number', 'number'])

  /**
   * Set Y ordinate values in a coordinate sequence.
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {number} val - the value to set the ordinate to
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_setY = null

  /**
   * Set Y ordinate values in a coordinate sequence.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {number} val - the value to set the ordinate to
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_setY_r = Module.cwrap('GEOSCoordSeq_setY_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Set Z ordinate values in a coordinate sequence.
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {number} val - the value to set the ordinate to
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_setZ = null

  /**
   * Set Z ordinate values in a coordinate sequence.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - the coordinate sequence
   * @param {number} idx - the index of the coordinate to alter, zero based
   * @param {number} val - the value to set the ordinate to
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSCoordSeq_setZ_r = Module.cwrap('GEOSCoordSeq_setZ_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Analyze a coverage (represented as a collection of polygonal geometry with exactly matching edge geometry) to find places where the assumption of exactly matching edges is not met.
   * @param {GEOSGeometry} input - The polygonal coverage to access, stored in a geometry collection. All members must be POLYGON or MULTIPOLYGON.
   * @param {number} gapWidth - The maximum width of gaps to detect.
   * @param {GEOSGeometry} invalidEdges - When there are invalidities in the coverage, this pointer will be set with a geometry collection of the same length as the input, with a MULTILINESTRING of the error edges for each invalid polygon, or an EMPTY where the polygon is a valid participant in the coverage. Pass NULL if you do not want the invalid edges returned.
   * @returns {number} A value of 1 for a valid coverage, 0 for invalid and 2 for an exception or error. Invalidity includes polygons that overlap, that have gaps smaller than the gapWidth, or non-polygonal entries in the input collection.
   * @alias module:geos
   */
  geos.GEOSCoverageIsValid = null

  /**
   * Analyze a coverage (represented as a collection of polygonal geometry with exactly matching edge geometry) to find places where the assumption of exactly matching edges is not met.
   * @param {GEOSContextHandle_t} extHandle -
   * @param {GEOSGeometry} input - The polygonal coverage to access, stored in a geometry collection. All members must be POLYGON or MULTIPOLYGON.
   * @param {number} gapWidth - The maximum width of gaps to detect.
   * @param {GEOSGeometry} output - When there are invalidities in the coverage, this pointer will be set with a geometry collection of the same length as the input, with a MULTILINESTRING of the error edges for each invalid polygon, or an EMPTY where the polygon is a valid participant in the coverage. Pass NULL if you do not want the invalid edges returned.
   * @returns {number} A value of 1 for a valid coverage, 0 for invalid and 2 for an exception or error. Invalidity includes polygons that overlap, that have gaps smaller than the gapWidth, or non-polygonal entries in the input collection.
   * @alias module:geos
   */
  geos.GEOSCoverageIsValid_r = Module.cwrap('GEOSCoverageIsValid_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Operates on a coverage (represented as a list of polygonal geometry with exactly matching edge geometry) to apply a Visvalingam–Whyatt simplification to the edges, reducing complexity in proportion with the provided tolerance, while retaining a valid coverage (no edges will cross or touch after the simplification). Geometries never disappear, but they may be simplified down to just a triangle. Also, some invalid geoms (such as Polygons which have too few non-repeated points) will be returned unchanged. If the input dataset is not a valid coverage due to overlaps, it will still be simplified, but invalid topology such as crossing edges will still be invalid.
   * @param {GEOSGeometry} input - The polygonal coverage to access, stored in a geometry collection. All members must be POLYGON or MULTIPOLYGON.
   * @param {number} tolerance - A tolerance parameter in linear units.
   * @param {number} preserveBoundary - Use 1 to preserve the outside edges of the coverage without simplification, 0 to allow them to be simplified.
   * @returns {GEOSGeometry} A collection containing the simplified geometries, or null on error.
   * @alias module:geos
   */
  geos.GEOSCoverageSimplifyVW = null

  /**
   * Operates on a coverage (represented as a list of polygonal geometry with exactly matching edge geometry) to apply a Visvalingam–Whyatt simplification to the edges, reducing complexity in proportion with the provided tolerance, while retaining a valid coverage (no edges will cross or touch after the simplification). Geometries never disappear, but they may be simplified down to just a triangle. Also, some invalid geoms (such as Polygons which have too few non-repeated points) will be returned unchanged. If the input dataset is not a valid coverage due to overlaps, it will still be simplified, but invalid topology such as crossing edges will still be invalid.
   * @param {GEOSContextHandle_t} extHandle -
   * @param {GEOSGeometry} input - The polygonal coverage to access, stored in a geometry collection. All members must be POLYGON or MULTIPOLYGON.
   * @param {number} tolerance - A tolerance parameter in linear units.
   * @param {number} preserveBoundary - Use 1 to preserve the outside edges of the coverage without simplification, 0 to allow them to be simplified.
   * @returns {GEOSGeometry} A collection containing the simplified geometries, or null on error.
   * @alias module:geos
   */
  geos.GEOSCoverageSimplifyVW_r = Module.cwrap('GEOSCoverageSimplifyVW_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Optimized union algorithm for polygonal inputs that are correctly noded and do not overlap. It may generate an error (return NULL) for inputs that do not satisfy this constraint, however this is not guaranteed.
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} A geometry that covers all the points of the input geometry. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSCoverageUnion = null

  /**
   * Optimized union algorithm for polygonal inputs that are correctly noded and do not overlap. It may generate an error (return NULL) for inputs that do not satisfy this constraint, however this is not guaranteed.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} A geometry that covers all the points of the input geometry. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSCoverageUnion_r = Module.cwrap('GEOSCoverageUnion_r', 'number', ['number', 'number'])

  /**
   * Tests if geometry g1 is covered by g2, which is the case if every point of g1 lies in g2.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSCoveredBy = null

  /**
   * Tests if geometry g1 is covered by g2, which is the case if every point of g1 lies in g2.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSCoveredBy_r = Module.cwrap('GEOSCoveredBy_r', 'number', ['number', 'number', 'number'])

  /**
   * Tests if geometry g1 covers g2, which is the case if every point of g2 lies in g1.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSCovers = null

  /**
   * Tests if geometry g1 covers g2, which is the case if every point of g2 lies in g1.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSCovers_r = Module.cwrap('GEOSCovers_r', 'number', ['number', 'number', 'number'])

  /**
   * Tests if two geometries interiors intersect but their boundaries do not. Most useful for finding line crosses cases.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSCrosses = null

  /**
   * Tests if two geometries interiors intersect but their boundaries do not. Most useful for finding line crosses cases.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSCrosses_r = Module.cwrap('GEOSCrosses_r', 'number', ['number', 'number', 'number'])

  /**
   * Return a Delaunay triangulation of the vertices of the given geometry.
   * @param {GEOSGeometry} g - the input geometry whose vertices will be used as "sites"
   * @param {number} tolerance - optional snapping tolerance to use for improved robustness
   * @param {number} onlyEdges - if non-zero will return a MultiLineString, otherwise it will return a GeometryCollection containing triangular Polygons.
   * @returns {GEOSGeometry} A newly allocated geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSDelaunayTriangulation = null

  /**
   * Return a Delaunay triangulation of the vertices of the given geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - the input geometry whose vertices will be used as "sites"
   * @param {number} tolerance - optional snapping tolerance to use for improved robustness
   * @param {number} onlyEdges - if non-zero will return a MultiLineString, otherwise it will return a GeometryCollection containing triangular Polygons.
   * @returns {GEOSGeometry} A newly allocated geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSDelaunayTriangulation_r = Module.cwrap('GEOSDelaunayTriangulation_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Densifies a geometry using a given distance tolerance. Additional vertices will be added to every line segment that is greater this tolerance; these vertices will evenly subdivide that segment. Only linear components of input geometry are densified.
   * @param {GEOSGeometry} g - The geometry to densify
   * @param {number} tolerance - the distance tolerance to densify
   * @returns {GEOSGeometry} The densified geometry, or NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSDensify = null

  /**
   * Densifies a geometry using a given distance tolerance. Additional vertices will be added to every line segment that is greater this tolerance; these vertices will evenly subdivide that segment. Only linear components of input geometry are densified.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The geometry to densify
   * @param {number} tolerance - the distance tolerance to densify
   * @returns {GEOSGeometry} The densified geometry, or NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSDensify_r = Module.cwrap('GEOSDensify_r', 'number', ['number', 'number', 'number'])

  /**
   * Returns the difference of two geometries A and B: the set of points that fall within A but not within B.
   * @param {GEOSGeometry} ga - the base geometry
   * @param {GEOSGeometry} gb - the geometry to subtract from it
   * @returns {GEOSGeometry} A newly allocated geometry of the difference. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSDifference = null

  /**
   * Returns the difference of two geometries A and B: the set of points that fall within A but not within B.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - the base geometry
   * @param {GEOSGeometry} g2 - the geometry to subtract from it
   * @returns {GEOSGeometry} A newly allocated geometry of the difference. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSDifference_r = Module.cwrap('GEOSDifference_r', 'number', ['number', 'number', 'number'])

  /**
   * Returns the difference of two geometries A and B: the set of points that fall within A but not within B. All the vertices of the output geometry must fall on the grid defined by the gridSize, and the output will be a valid geometry.
   * @param {GEOSGeometry} ga - one of the geometries
   * @param {GEOSGeometry} gb - the other geometry
   * @param {number} gridSize - the cell size of the precision grid
   * @returns {GEOSGeometry} A newly allocated geometry of the difference. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSDifferencePrec = null

  /**
   * Returns the difference of two geometries A and B: the set of points that fall within A but not within B. All the vertices of the output geometry must fall on the grid defined by the gridSize, and the output will be a valid geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - one of the geometries
   * @param {GEOSGeometry} g2 - the other geometry
   * @param {number} gridSize - the cell size of the precision grid
   * @returns {GEOSGeometry} A newly allocated geometry of the difference. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSDifferencePrec_r = Module.cwrap('GEOSDifferencePrec_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Tests if two geometries have no point in common.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSDisjoint = null

  /**
   * Tests if two geometries have no point in common.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSDisjoint_r = Module.cwrap('GEOSDisjoint_r', 'number', ['number', 'number', 'number'])

  /**
   * Optimized union algorithm for inputs that can be divided into subsets that do not intersect. If there is only one such subset, performance can be expected to be worse than GEOSUnionaryUnion.
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} A newly allocated geometry of the union, or NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSDisjointSubsetUnion = null

  /**
   * Optimized union algorithm for inputs that can be divided into subsets that do not intersect. If there is only one such subset, performance can be expected to be worse than GEOSUnionaryUnion.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} A newly allocated geometry of the union, or NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSDisjointSubsetUnion_r = Module.cwrap('GEOSDisjointSubsetUnion_r', 'number', ['number', 'number'])

  /**
   * Calculate the distance between two geometries.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @param {NumberPointer} dist - Pointer to be filled in with distance result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSDistance = null

  /**
   * Calculate the distance between two geometries.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @param {NumberPointer} dist - Pointer to be filled in with distance result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSDistance_r = Module.cwrap('GEOSDistance_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Calculate the distance between two geometries, using the indexed facet distance, which first indexes the geometries internally, then calculates the distance. Useful when one or both geometries is very large.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @param {NumberPointer} dist - Pointer to be filled in with distance result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSDistanceIndexed = null

  /**
   * Calculate the distance between two geometries, using the indexed facet distance, which first indexes the geometries internally, then calculates the distance. Useful when one or both geometries is very large.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @param {NumberPointer} dist - Pointer to be filled in with distance result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSDistanceIndexed_r = Module.cwrap('GEOSDistanceIndexed_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Test whether the distance between two geometries is within the given dist.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @param {number} dist - The max distance
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSDistanceWithin = null

  /**
   * Test whether the distance between two geometries is within the given dist.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @param {number} dist - The max distance
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSDistanceWithin_r = Module.cwrap('GEOSDistanceWithin_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Returns minimum rectangular polygon or point that contains the geometry, or an empty point for empty inputs.
   * @param {GEOSGeometry} g - The geometry to calculate an envelope for
   * @returns {GEOSGeometry} A newly allocated polygonal envelope or point. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSEnvelope = null

  /**
   * Returns minimum rectangular polygon or point that contains the geometry, or an empty point for empty inputs.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The geometry to calculate an envelope for
   * @returns {GEOSGeometry} A newly allocated polygonal envelope or point. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSEnvelope_r = Module.cwrap('GEOSEnvelope_r', 'number', ['number', 'number'])

  /**
   * Tests if two geometries contain the same set of points in the plane.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSEquals = null

  /**
   * Tests if two geometries contain the same set of points in the plane.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSEquals_r = Module.cwrap('GEOSEquals_r', 'number', ['number', 'number', 'number'])

  /**
   * Determine pointwise equality of two geometries, by checking that they have identical structure and that each vertex of g2 is within the distance tolerance of the corresponding vertex in g1. Z and M values are ignored by GEOSEqualsExact, and this function may return true for inputs with different dimensionality. Unlike GEOSEquals(), geometries that are topologically equivalent but have different representations (e.g., LINESTRING (0 0, 1 1) and MULTILINESTRING ((0 0, 1 1)) ) are not considered equal by GEOSEqualsExact().
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @param {number} tolerance - Tolerance to determine vertex equality
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSEqualsExact = null

  /**
   * Determine pointwise equality of two geometries, by checking that they have identical structure and that each vertex of g2 is within the distance tolerance of the corresponding vertex in g1. Z and M values are ignored by GEOSEqualsExact, and this function may return true for inputs with different dimensionality. Unlike GEOSEquals(), geometries that are topologically equivalent but have different representations (e.g., LINESTRING (0 0, 1 1) and MULTILINESTRING ((0 0, 1 1)) ) are not considered equal by GEOSEqualsExact().
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @param {number} tolerance - Tolerance to determine vertex equality
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSEqualsExact_r = Module.cwrap('GEOSEqualsExact_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Determine pointwise equality of two geometries by checking that the structure, ordering, and values of all vertices are identical in all dimensions. NaN values are considered to be equal to other NaN values.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSEqualsIdentical = null

  /**
   * Determine pointwise equality of two geometries by checking that the structure, ordering, and values of all vertices are identical in all dimensions. NaN values are considered to be equal to other NaN values.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSEqualsIdentical_r = Module.cwrap('GEOSEqualsIdentical_r', 'number', ['number', 'number', 'number'])

  /**
   * Calculate the Frechet distance between two geometries, a similarity measure for linear features.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @param {NumberPointer} dist - Pointer to be filled in with distance result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSFrechetDistance = null

  /**
   * Calculate the Frechet distance between two geometries, a similarity measure for linear features.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @param {NumberPointer} dist - Pointer to be filled in with distance result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSFrechetDistance_r = Module.cwrap('GEOSFrechetDistance_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Calculate the Frechet distance between two geometries, a similarity measure for linear features. The inputs can be densified to provide a more accurate result.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @param {number} densifyFrac - The largest % of the overall line length that any given two-point segment should be
   * @param {NumberPointer} dist - Pointer to be filled in with distance result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSFrechetDistanceDensify = null

  /**
   * Calculate the Frechet distance between two geometries, a similarity measure for linear features. The inputs can be densified to provide a more accurate result.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @param {number} densifyFrac - The largest % of the overall line length that any given two-point segment should be
   * @param {NumberPointer} dist - Pointer to be filled in with distance result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSFrechetDistanceDensify_r = Module.cwrap('GEOSFrechetDistanceDensify_r', 'number', ['number', 'number', 'number', 'number', 'number'])

  /**
   * Free strings and byte buffers returned by functions such as GEOSWKBWriter_write(), GEOSWKBWriter_writeHEX() and GEOSWKTWriter_write(), etc. If passed a null pointer the function does nothing.
   * @param {Pointer} buffer - The memory to free (may be null)
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSFree = null

  /**
   * Free strings and byte buffers returned by functions such as GEOSWKBWriter_write(), GEOSWKBWriter_writeHEX() and GEOSWKTWriter_write(), etc. If passed a null pointer the function does nothing.
   * @param {GEOSContextHandle_t} handle -
   * @param {Pointer} buffer - The memory to free (may be null)
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSFree_r = Module.cwrap('GEOSFree_r', 'null', ['number', 'number'])

  /**
   * Allocate a new GEOSGeoJSONReader.
   * @returns {GEOSGeoJSONReader} a new reader. Caller must free with GEOSGeoJSONReader_destroy()
   * @alias module:geos
   */
  geos.GEOSGeoJSONReader_create = null

  /**
   * Allocate a new GEOSGeoJSONReader.
   * @param {GEOSContextHandle_t} handle -
   * @returns {GEOSGeoJSONReader} a new reader. Caller must free with GEOSGeoJSONReader_destroy()
   * @alias module:geos
   */
  geos.GEOSGeoJSONReader_create_r = Module.cwrap('GEOSGeoJSONReader_create_r', 'number', ['number'])

  /**
   * Free the memory associated with a GEOSGeoJSONReader.
   * @param {GEOSGeoJSONReader} reader - The reader to destroy.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSGeoJSONReader_destroy = null

  /**
   * Free the memory associated with a GEOSGeoJSONReader.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeoJSONReader} reader - The reader to destroy.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSGeoJSONReader_destroy_r = Module.cwrap('GEOSGeoJSONReader_destroy_r', 'null', ['number', 'number'])

  /**
   * Use a reader to parse a GeoJSON string. A single geometry or Feature is parsed as a geometry. A FeatureCollection is parsed as a GeometryCollection. Feature properties are not read.
   * @param {GEOSGeoJSONReader} reader - A GeoJSON reader object, caller retains ownership
   * @param {StringPointer} geojson - The json string to parse, caller retains ownership
   * @returns {GEOSGeometry} A GEOSGeometry, caller to free with GEOSGeom_destroy())
   * @alias module:geos
   */
  geos.GEOSGeoJSONReader_readGeometry = null

  /**
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeoJSONReader} reader -
   * @param {StringPointer} geojson -
   * @returns {GEOSGeometry} GEOSGeometry*
   * @alias module:geos
   */
  geos.GEOSGeoJSONReader_readGeometry_r = Module.cwrap('GEOSGeoJSONReader_readGeometry_r', 'number', ['number', 'number', 'number'])

  /**
   * Allocate a new GEOSGeoJSONWriter.
   * @returns {GEOSGeoJSONWriter} a new writer. Caller must free with GEOSGeoJSONWriter_destroy()
   * @alias module:geos
   */
  geos.GEOSGeoJSONWriter_create = null

  /**
   * Allocate a new GEOSGeoJSONWriter.
   * @param {GEOSContextHandle_t} handle -
   * @returns {GEOSGeoJSONWriter} a new writer. Caller must free with GEOSGeoJSONWriter_destroy()
   * @alias module:geos
   */
  geos.GEOSGeoJSONWriter_create_r = Module.cwrap('GEOSGeoJSONWriter_create_r', 'number', ['number'])

  /**
   * Free the memory associated with a GEOSGeoJSONWriter.
   * @param {GEOSGeoJSONWriter} writer - The writer to destroy.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSGeoJSONWriter_destroy = null

  /**
   * Free the memory associated with a GEOSGeoJSONWriter.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeoJSONWriter} writer - The writer to destroy.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSGeoJSONWriter_destroy_r = Module.cwrap('GEOSGeoJSONWriter_destroy_r', 'null', ['number', 'number'])

  /**
   * Write out the GeoJSON representation of a geometry. Note that writing a GeoJSON Feature or FeatureCollection is unsupported through the GEOS C API.
   * @param {GEOSGeoJSONWriter} writer - A GeoJSON reader object, caller retains ownership.
   * @param {GEOSGeometry} g - The geometry to convert, caller retains ownership.
   * @param {number} indent - The indentation used. Use -1 for no formatting.
   * @returns {StringPointer} A char pointer, caller to free with GEOSFree())
   * @alias module:geos
   */
  geos.GEOSGeoJSONWriter_writeGeometry = null

  /**
   * Write out the GeoJSON representation of a geometry. Note that writing a GeoJSON Feature or FeatureCollection is unsupported through the GEOS C API.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeoJSONWriter} writer - A GeoJSON reader object, caller retains ownership.
   * @param {GEOSGeometry} g - The geometry to convert, caller retains ownership.
   * @param {number} indent - The indentation used. Use -1 for no formatting.
   * @returns {StringPointer} A char pointer, caller to free with GEOSFree())
   * @alias module:geos
   */
  geos.GEOSGeoJSONWriter_writeGeometry_r = Module.cwrap('GEOSGeoJSONWriter_writeGeometry_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Create a new copy of the input geometry.
   * @param {GEOSGeometry} g - The geometry to copy
   * @returns {GEOSGeometry} A newly allocated geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_clone = null

  /**
   * Create a new copy of the input geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The geometry to copy
   * @returns {GEOSGeometry} A newly allocated geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_clone_r = Module.cwrap('GEOSGeom_clone_r', 'number', ['number', 'number'])

  /**
   * Creates a CircularString geometry.
   * @param {GEOSCoordSequence} s - Input coordinate sequence, ownership passes to the geometry
   * @returns {GEOSGeometry} A newly allocated CircularString geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createCircularString = null

  /**
   * Creates a CircularString geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - Input coordinate sequence, ownership passes to the geometry
   * @returns {GEOSGeometry} A newly allocated CircularString geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createCircularString_r = Module.cwrap('GEOSGeom_createCircularString_r', 'number', ['number', 'number'])

  /**
   * Create a geometry collection.
   * @param {number} type - The geometry type, enumerated by GEOSGeomTypes
   * @param {GEOSGeometry} geoms - A list of geometries that will form the collection
   * @param {number} ngeoms - The number of geometries in the geoms list
   * @returns {GEOSGeometry} A newly allocated geometry collection. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createCollection = null

  /**
   * Create a geometry collection.
   * @param {GEOSContextHandle_t} handle -
   * @param {number} type - The geometry type, enumerated by GEOSGeomTypes
   * @param {GEOSGeometry} geoms - A list of geometries that will form the collection
   * @param {number} ngeoms - The number of geometries in the geoms list
   * @returns {GEOSGeometry} A newly allocated geometry collection. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createCollection_r = Module.cwrap('GEOSGeom_createCollection_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Creates a CompoundCurve geometry.
   * @param {GEOSGeometry} curves - A list of geometries that will form the CompoundCurve
   * @param {number} ncurves - The number of geometries in the curves list
   * @returns {GEOSGeometry} A newly allocated CompoundCurve geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createCompoundCurve = null

  /**
   * Creates a CompoundCurve geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} curves - A list of geometries that will form the CompoundCurve
   * @param {number} ncurves - The number of geometries in the curves list
   * @returns {GEOSGeometry} A newly allocated CompoundCurve geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createCompoundCurve_r = Module.cwrap('GEOSGeom_createCompoundCurve_r', 'number', ['number', 'number', 'number'])

  /**
   * Creates a CurvePolygon geometry from ring geometries.
   * @param {GEOSGeometry} shell - A ring that is the exterior ring of the polygon.
   * @param {GEOSGeometry} holes - An array of rings that are the holes.
   * @param {number} nholes - The number of rings in the holes array.
   * @returns {GEOSGeometry} A newly allocated geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createCurvePolygon = null

  /**
   * Creates a CurvePolygon geometry from ring geometries.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} shell - A ring that is the exterior ring of the polygon.
   * @param {GEOSGeometry} holes - An array of rings that are the holes.
   * @param {number} nholes - The number of rings in the holes array.
   * @returns {GEOSGeometry} A newly allocated geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createCurvePolygon_r = Module.cwrap('GEOSGeom_createCurvePolygon_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Creates an empty CircularString geometry.
   * @returns {GEOSGeometry} A newly allocated CircularString geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createEmptyCircularString = null

  /**
   * Creates an empty CircularString geometry.
   * @param {GEOSContextHandle_t} handle -
   * @returns {GEOSGeometry} A newly allocated CircularString geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createEmptyCircularString_r = Module.cwrap('GEOSGeom_createEmptyCircularString_r', 'number', ['number'])

  /**
   * Create an empty geometry collection.
   * @param {number} type - The geometry type, enumerated by GEOSGeomTypes
   * @returns {GEOSGeometry} A newly allocated empty geometry collection. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createEmptyCollection = null

  /**
   * Create an empty geometry collection.
   * @param {GEOSContextHandle_t} handle -
   * @param {number} type - The geometry type, enumerated by GEOSGeomTypes
   * @returns {GEOSGeometry} A newly allocated empty geometry collection. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createEmptyCollection_r = Module.cwrap('GEOSGeom_createEmptyCollection_r', 'number', ['number', 'number'])

  /**
   * Creates an empty CompoundCurve geometry.
   * @returns {GEOSGeometry} A newly allocated CompoundCurve geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createEmptyCompoundCurve = null

  /**
   * Creates an empty CompoundCurve geometry.
   * @param {GEOSContextHandle_t} handle -
   * @returns {GEOSGeometry} A newly allocated CompoundCurve geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createEmptyCompoundCurve_r = Module.cwrap('GEOSGeom_createEmptyCompoundCurve_r', 'number', ['number'])

  /**
   * Creates an empty CurvePolygon geometry.
   * @returns {GEOSGeometry} A newly allocated CurvePolygon geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createEmptyCurvePolygon = null

  /**
   * Creates an empty CurvePolygon geometry.
   * @param {GEOSContextHandle_t} handle -
   * @returns {GEOSGeometry} A newly allocated CurvePolygon geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createEmptyCurvePolygon_r = Module.cwrap('GEOSGeom_createEmptyCurvePolygon_r', 'number', ['number'])

  /**
   * Creates an emptylinestring geometry.
   * @returns {GEOSGeometry} A newly allocated linestring geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createEmptyLineString = null

  /**
   * Creates an emptylinestring geometry.
   * @param {GEOSContextHandle_t} handle -
   * @returns {GEOSGeometry} A newly allocated linestring geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createEmptyLineString_r = Module.cwrap('GEOSGeom_createEmptyLineString_r', 'number', ['number'])

  /**
   * Creates an empty point.
   * @returns {GEOSGeometry} A newly allocated empty point geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createEmptyPoint = null

  /**
   * Creates an empty point.
   * @param {GEOSContextHandle_t} handle -
   * @returns {GEOSGeometry} A newly allocated empty point geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createEmptyPoint_r = Module.cwrap('GEOSGeom_createEmptyPoint_r', 'number', ['number'])

  /**
   * Creates an empty polygon geometry.
   * @returns {GEOSGeometry} A newly allocated empty polygon geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createEmptyPolygon = null

  /**
   * Creates an empty polygon geometry.
   * @param {GEOSContextHandle_t} handle -
   * @returns {GEOSGeometry} A newly allocated empty polygon geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createEmptyPolygon_r = Module.cwrap('GEOSGeom_createEmptyPolygon_r', 'number', ['number'])

  /**
   * Creates a linear ring geometry, for use in a polygon.
   * @param {GEOSCoordSequence} s - Input coordinate sequence, ownership passes to the geometry
   * @returns {GEOSGeometry} A newly allocated linear ring geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createLinearRing = null

  /**
   * Creates a linear ring geometry, for use in a polygon.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - Input coordinate sequence, ownership passes to the geometry
   * @returns {GEOSGeometry} A newly allocated linear ring geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createLinearRing_r = Module.cwrap('GEOSGeom_createLinearRing_r', 'number', ['number', 'number'])

  /**
   * Creates a linestring geometry.
   * @param {GEOSCoordSequence} s - Input coordinate sequence, ownership passes to the geometry
   * @returns {GEOSGeometry} A newly allocated linestring geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createLineString = null

  /**
   * Creates a linestring geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - Input coordinate sequence, ownership passes to the geometry
   * @returns {GEOSGeometry} A newly allocated linestring geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createLineString_r = Module.cwrap('GEOSGeom_createLineString_r', 'number', ['number', 'number'])

  /**
   * Creates a point geometry from a coordinate sequence.
   * @param {GEOSCoordSequence} s - Input coordinate sequence, ownership passes to the geometry
   * @returns {GEOSGeometry} A newly allocated point geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createPoint = null

  /**
   * Creates a point geometry from a coordinate sequence.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSCoordSequence} s - Input coordinate sequence, ownership passes to the geometry
   * @returns {GEOSGeometry} A newly allocated point geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createPoint_r = Module.cwrap('GEOSGeom_createPoint_r', 'number', ['number', 'number'])

  /**
   * Creates a point geometry from a pair of coordinates.
   * @param {number} x - The X coordinate
   * @param {number} y - The Y coordinate
   * @returns {GEOSGeometry} A newly allocated point geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createPointFromXY = null

  /**
   * Creates a point geometry from a pair of coordinates.
   * @param {GEOSContextHandle_t} handle -
   * @param {number} x - The X coordinate
   * @param {number} y - The Y coordinate
   * @returns {GEOSGeometry} A newly allocated point geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createPointFromXY_r = Module.cwrap('GEOSGeom_createPointFromXY_r', 'number', ['number', 'number', 'number'])

  /**
   * Creates a polygon geometry from linear ring geometries.
   * @param {GEOSGeometry} shell - A linear ring that is the exterior ring of the polygon.
   * @param {GEOSGeometry} holes - An array of linear rings that are the holes.
   * @param {number} nholes - The number of rings in the holes array.
   * @returns {GEOSGeometry} A newly allocated geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createPolygon = null

  /**
   * Creates a polygon geometry from linear ring geometries.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} shell - A linear ring that is the exterior ring of the polygon.
   * @param {GEOSGeometry} holes - An array of linear rings that are the holes.
   * @param {number} nholes - The number of rings in the holes array.
   * @returns {GEOSGeometry} A newly allocated geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_createPolygon_r = Module.cwrap('GEOSGeom_createPolygon_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Create a rectangular polygon from bounding coordinates. Will return a point geometry if width and height are 0.
   * @param {number} xmin - Left bound of envelope
   * @param {number} ymin - Lower bound of envelope
   * @param {number} xmax - Right bound of envelope
   * @param {number} ymax - Upper bound of envelope
   * @returns {GEOSGeometry} GEOSGeometry*
   * @alias module:geos
   */
  geos.GEOSGeom_createRectangle = null

  /**
   * Create a rectangular polygon from bounding coordinates. Will return a point geometry if width and height are 0.
   * @param {GEOSContextHandle_t} handle -
   * @param {number} xmin - Left bound of envelope
   * @param {number} ymin - Lower bound of envelope
   * @param {number} xmax - Right bound of envelope
   * @param {number} ymax - Upper bound of envelope
   * @returns {GEOSGeometry} GEOSGeometry*
   * @alias module:geos
   */
  geos.GEOSGeom_createRectangle_r = Module.cwrap('GEOSGeom_createRectangle_r', 'number', ['number', 'number', 'number', 'number', 'number'])

  /**
   * Release the memory associated with a geometry.
   * @param {GEOSGeometry} g - The geometry to be destroyed.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSGeom_destroy = null

  /**
   * Release the memory associated with a geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The geometry to be destroyed.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSGeom_destroy_r = Module.cwrap('GEOSGeom_destroy_r', 'null', ['number', 'number'])

  /**
   * Return all distinct vertices of input geometry as a MultiPoint. Note that only 2 dimensions of the vertices are considered when testing for equality.
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} The distinct points Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_extractUniquePoints = null

  /**
   * Return all distinct vertices of input geometry as a MultiPoint. Note that only 2 dimensions of the vertices are considered when testing for equality.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} The distinct points Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_extractUniquePoints_r = Module.cwrap('GEOSGeom_extractUniquePoints_r', 'number', ['number', 'number'])

  /**
   * Return the cartesian dimension of the geometry.
   * @param {GEOSGeometry} g - Input geometry
   * @returns {number} The dimension
   * @alias module:geos
   */
  geos.GEOSGeom_getCoordinateDimension = null

  /**
   * Return the cartesian dimension of the geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @returns {number} The dimension
   * @alias module:geos
   */
  geos.GEOSGeom_getCoordinateDimension_r = Module.cwrap('GEOSGeom_getCoordinateDimension_r', 'number', ['number', 'number'])

  /**
   * Return the coordinate sequence underlying the given geometry (Must be a LineString, LinearRing or Point). Do not directly free the coordinate sequence, it is owned by the parent geometry.
   * @param {GEOSGeometry} g - Input geometry
   * @returns {number} Coordinate sequence or NULL on exception.
   * @alias module:geos
   */
  geos.GEOSGeom_getCoordSeq = null

  /**
   * Return the coordinate sequence underlying the given geometry (Must be a LineString, LinearRing or Point). Do not directly free the coordinate sequence, it is owned by the parent geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @returns {number} Coordinate sequence or NULL on exception.
   * @alias module:geos
   */
  geos.GEOSGeom_getCoordSeq_r = Module.cwrap('GEOSGeom_getCoordSeq_r', 'number', ['number', 'number'])

  /**
   * Return the planar dimensionality of the geometry.
   * @param {GEOSGeometry} g - Input geometry
   * @returns {number} The dimensionality
   * @alias module:geos
   */
  geos.GEOSGeom_getDimensions = null

  /**
   * Return the planar dimensionality of the geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @returns {number} The dimensionality
   * @alias module:geos
   */
  geos.GEOSGeom_getDimensions_r = Module.cwrap('GEOSGeom_getDimensions_r', 'number', ['number', 'number'])

  /**
   * Finds the extent (minimum and maximum X and Y value) of the geometry. Raises an exception for empty geometry input.
   * @param {GEOSGeometry} g - Input geometry
   * @param {NumberPointer} xmin - Pointer to place result for minimum X value
   * @param {NumberPointer} ymin - Pointer to place result for minimum Y value
   * @param {NumberPointer} xmax - Pointer to place result for maximum X value
   * @param {NumberPointer} ymax - Pointer to place result for maximum Y value
   * @returns {number} 1 on success, 0 on exception
   * @alias module:geos
   */
  geos.GEOSGeom_getExtent = null

  /**
   * Finds the extent (minimum and maximum X and Y value) of the geometry. Raises an exception for empty geometry input.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @param {NumberPointer} xmin - Pointer to place result for minimum X value
   * @param {NumberPointer} ymin - Pointer to place result for minimum Y value
   * @param {NumberPointer} xmax - Pointer to place result for maximum X value
   * @param {NumberPointer} ymax - Pointer to place result for maximum Y value
   * @returns {number} 1 on success, 0 on exception
   * @alias module:geos
   */
  geos.GEOSGeom_getExtent_r = Module.cwrap('GEOSGeom_getExtent_r', 'number', ['number', 'number', 'number', 'number', 'number', 'number'])

  /**
   * Read the currently set precision value from the geometry and returns the grid size if it is a fixed precision or 0.0 if it is full floating point precision.
   * @param {GEOSGeometry} g - Input geometry
   * @returns {number} The grid size, or -1 on exception
   * @alias module:geos
   */
  geos.GEOSGeom_getPrecision = null

  /**
   * Read the currently set precision value from the geometry and returns the grid size if it is a fixed precision or 0.0 if it is full floating point precision.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @returns {number} The grid size, or -1 on exception
   * @alias module:geos
   */
  geos.GEOSGeom_getPrecision_r = Module.cwrap('GEOSGeom_getPrecision_r', 'number', ['number', 'number'])

  /**
   * Return the anonymous "user data" for this geometry. User data must be managed by the caller, and is not freed when the geometry is destroyed.
   * @param {GEOSGeometry} g - Input geometry
   * @returns {Pointer} A void* to the user data, caller is responsible for casting to the appropriate type.
   * @alias module:geos
   */
  geos.GEOSGeom_getUserData = null

  /**
   * Return the anonymous "user data" for this geometry. User data must be managed by the caller, and is not freed when the geometry is destroyed.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @returns {Pointer} A void* to the user data, caller is responsible for casting to the appropriate type.
   * @alias module:geos
   */
  geos.GEOSGeom_getUserData_r = Module.cwrap('GEOSGeom_getUserData_r', 'null', ['number', 'number'])

  /**
   * Finds the maximum X value in the geometry.
   * @param {GEOSGeometry} g - Input geometry
   * @param {NumberPointer} value - Pointer to place result
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSGeom_getXMax = null

  /**
   * Finds the maximum X value in the geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @param {NumberPointer} value - Pointer to place result
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSGeom_getXMax_r = Module.cwrap('GEOSGeom_getXMax_r', 'number', ['number', 'number', 'number'])

  /**
   * Finds the minimum X value in the geometry.
   * @param {GEOSGeometry} g - Input geometry
   * @param {NumberPointer} value - Pointer to place result
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSGeom_getXMin = null

  /**
   * Finds the minimum X value in the geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @param {NumberPointer} value - Pointer to place result
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSGeom_getXMin_r = Module.cwrap('GEOSGeom_getXMin_r', 'number', ['number', 'number', 'number'])

  /**
   * Finds the maximum Y value in the geometry.
   * @param {GEOSGeometry} g - Input geometry
   * @param {NumberPointer} value - Pointer to place result
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSGeom_getYMax = null

  /**
   * Finds the maximum Y value in the geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @param {NumberPointer} value - Pointer to place result
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSGeom_getYMax_r = Module.cwrap('GEOSGeom_getYMax_r', 'number', ['number', 'number', 'number'])

  /**
   * Finds the minimum Y value in the geometry.
   * @param {GEOSGeometry} g - Input geometry
   * @param {NumberPointer} value - Pointer to place result
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSGeom_getYMin = null

  /**
   * Finds the minimum Y value in the geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @param {NumberPointer} value - Pointer to place result
   * @returns {number} 0 on exception
   * @alias module:geos
   */
  geos.GEOSGeom_getYMin_r = Module.cwrap('GEOSGeom_getYMin_r', 'number', ['number', 'number', 'number'])

  /**
   * Release the sub-geometries of a collection for management. by the caller. The input collection remains as an empty collection, that the caller is responsible for destroying. The output geometries are also the responsibility of the caller, as is the containing array, which must be freed with GEOSFree().
   * @param {GEOSGeometry} collection - The collection that will have its components released.
   * @param {NumberPointer} ngeoms - A pointer to a variable that will be filled with the size of the output array.
   * @returns {GEOSGeometry} A newly allocated array of GEOSGeometry pointers.
   * @alias module:geos
   */
  geos.GEOSGeom_releaseCollection = null

  /**
   * Release the sub-geometries of a collection for management. by the caller. The input collection remains as an empty collection, that the caller is responsible for destroying. The output geometries are also the responsibility of the caller, as is the containing array, which must be freed with GEOSFree().
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} collection - The collection that will have its components released.
   * @param {NumberPointer} ngeoms - A pointer to a variable that will be filled with the size of the output array.
   * @returns {GEOSGeometry} A newly allocated array of GEOSGeometry pointers.
   * @alias module:geos
   */
  geos.GEOSGeom_releaseCollection_r = Module.cwrap('GEOSGeom_releaseCollection_r', 'number', ['number', 'number', 'number'])

  /**
   * Change the coordinate precision of a geometry. This will affect the precision of the existing geometry as well as any geometries derived from this geometry using overlay functions. The output will be a valid GEOSGeometry.
   * @param {GEOSGeometry} g - Input geometry
   * @param {number} gridSize - cell size of grid to round coordinates to, or 0 for FLOATING precision
   * @param {number} flags - The bitwise OR of members of the GEOSPrecisionRules enum
   * @returns {GEOSGeometry} The precision reduced result. Caller must free with GEOSGeom_destroy() NULL on exception.
   * @alias module:geos
   */
  geos.GEOSGeom_setPrecision = null

  /**
   * Change the coordinate precision of a geometry. This will affect the precision of the existing geometry as well as any geometries derived from this geometry using overlay functions. The output will be a valid GEOSGeometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @param {number} gridSize - cell size of grid to round coordinates to, or 0 for FLOATING precision
   * @param {number} flags - The bitwise OR of members of the GEOSPrecisionRules enum
   * @returns {GEOSGeometry} The precision reduced result. Caller must free with GEOSGeom_destroy() NULL on exception.
   * @alias module:geos
   */
  geos.GEOSGeom_setPrecision_r = Module.cwrap('GEOSGeom_setPrecision_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Set the anonymous "user data" for this geometry.
   * @param {GEOSGeometry} g - Input geometry
   * @param {Pointer} userData - Void pointer to user data
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSGeom_setUserData = null

  /**
   * Set the anonymous "user data" for this geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @param {Pointer} userData - Void pointer to user data
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSGeom_setUserData_r = Module.cwrap('GEOSGeom_setUserData_r', 'null', ['number', 'number', 'number'])

  /**
   * Apply XY coordinate transform callback to all coordinates in a copy of input geometry. If the callback returns an error, returned geometry will be NULL. Z and M values, if present, are not modified by this function.
   * @param {GEOSGeometry} g - Input geometry
   * @param {GEOSTransformXYCallback} callback - a function to be executed for each coordinate in the geometry. The callback takes 3 parameters: x and y coordinate values to be updated and a void userdata pointer.
   * @param {Pointer} userdata - an optional pointer to pe passed to 'callback' as an argument
   * @returns {GEOSGeometry} a copy of the input geometry with transformed coordinates. Caller must free with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_transformXY = null

  /**
   * Apply XY coordinate transform callback to all coordinates in a copy of input geometry. If the callback returns an error, returned geometry will be NULL. Z and M values, if present, are not modified by this function.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @param {GEOSTransformXYCallback} callback - a function to be executed for each coordinate in the geometry. The callback takes 3 parameters: x and y coordinate values to be updated and a void userdata pointer.
   * @param {Pointer} userdata - an optional pointer to pe passed to 'callback' as an argument
   * @returns {GEOSGeometry} a copy of the input geometry with transformed coordinates. Caller must free with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGeom_transformXY_r = Module.cwrap('GEOSGeom_transformXY_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * @param {Pointer} hex -
   * @param {number} size -
   * @returns {GEOSGeometry} GEOSGeometry*
   * @deprecated use GEOSWKBReader and GEOSWKBWriter_readHEX()
   * @alias module:geos
   */
  geos.GEOSGeomFromHEX_buf = null

  /**
   * @param {GEOSContextHandle_t} handle -
   * @param {Pointer} hex -
   * @param {number} size -
   * @returns {GEOSGeometry} GEOSGeometry*
   * @deprecated use GEOSWKBReader and GEOSWKBReader_readHEX_r()
   * @alias module:geos
   */
  geos.GEOSGeomFromHEX_buf_r = Module.cwrap('GEOSGeomFromHEX_buf_r', 'number', ['number', 'number', 'number'])

  /**
   * @param {Pointer} wkb -
   * @param {number} size -
   * @returns {GEOSGeometry} GEOSGeometry*
   * @deprecated use GEOSWKBReader and GEOSWKBWriter_read()
   * @alias module:geos
   */
  geos.GEOSGeomFromWKB_buf = null

  /**
   * @param {GEOSContextHandle_t} handle -
   * @param {Pointer} wkb -
   * @param {number} size -
   * @returns {GEOSGeometry} GEOSGeometry*
   * @deprecated use GEOSWKBReader and GEOSWKBReader_read_r()
   * @alias module:geos
   */
  geos.GEOSGeomFromWKB_buf_r = Module.cwrap('GEOSGeomFromWKB_buf_r', 'number', ['number', 'number', 'number'])

  /**
   * @param {StringPointer} wkt -
   * @returns {GEOSGeometry} GEOSGeometry*
   * @deprecated use GEOSWKTReader and GEOSWKTReader_read_r()
   * @alias module:geos
   */
  geos.GEOSGeomFromWKT = null

  /**
   * @param {GEOSContextHandle_t} handle -
   * @param {StringPointer} wkt -
   * @returns {GEOSGeometry} GEOSGeometry*
   * @deprecated use GEOSWKTReader and GEOSWKTReader_read_r()
   * @alias module:geos
   */
  geos.GEOSGeomFromWKT_r = Module.cwrap('GEOSGeomFromWKT_r', 'number', ['number', 'number'])

  /**
   * Return the last point of a LineString
   * @param {GEOSGeometry} g - Input geometry, must be a LineString
   * @returns {GEOSGeometry} A Point geometry. Caller must free with GEOSGeom_destroy() NULL on exception.
   * @alias module:geos
   */
  geos.GEOSGeomGetEndPoint = null

  /**
   * Return the last point of a LineString
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry, must be a LineString
   * @returns {GEOSGeometry} A Point geometry. Caller must free with GEOSGeom_destroy() NULL on exception.
   * @alias module:geos
   */
  geos.GEOSGeomGetEndPoint_r = Module.cwrap('GEOSGeomGetEndPoint_r', 'number', ['number', 'number'])

  /**
   * Calculate the length of a LineString. Only works for LineString inputs, returns exception otherwise.
   * @param {GEOSGeometry} g - Input geometry
   * @param {NumberPointer} length - Pointer to be filled in with length result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSGeomGetLength = null

  /**
   * Calculate the length of a LineString. Only works for LineString inputs, returns exception otherwise.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @param {NumberPointer} length - Pointer to be filled in with length result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSGeomGetLength_r = Module.cwrap('GEOSGeomGetLength_r', 'number', ['number', 'number', 'number'])

  /**
   * Returns the M coordinate, for a Point input, or an exception otherwise.
   * @param {GEOSGeometry} g - Input Point geometry
   * @param {NumberPointer} m - Pointer to hold return value
   * @returns {number} 1 on success, 0 on exception
   * @alias module:geos
   */
  geos.GEOSGeomGetM = null

  /**
   * Returns the M coordinate, for a Point input, or an exception otherwise.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input Point geometry
   * @param {NumberPointer} m - Pointer to hold return value
   * @returns {number} 1 on success, 0 on exception
   * @alias module:geos
   */
  geos.GEOSGeomGetM_r = Module.cwrap('GEOSGeomGetM_r', 'number', ['number', 'number', 'number'])

  /**
   * Returns the number of points, for a LineString input, or an exception otherwise.
   * @param {GEOSGeometry} g - Input LineString geometry
   * @returns {number} Number of points, -1 on exception
   * @alias module:geos
   */
  geos.GEOSGeomGetNumPoints = null

  /**
   * Returns the number of points, for a LineString input, or an exception otherwise.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input LineString geometry
   * @returns {number} Number of points, -1 on exception
   * @alias module:geos
   */
  geos.GEOSGeomGetNumPoints_r = Module.cwrap('GEOSGeomGetNumPoints_r', 'number', ['number', 'number'])

  /**
   * Return the N'th point of a LineString
   * @param {GEOSGeometry} g - Input geometry, must be a LineString
   * @param {number} n - Index of desired point (zero based)
   * @returns {GEOSGeometry} A Point geometry. Caller must free with GEOSGeom_destroy() NULL on exception.
   * @alias module:geos
   */
  geos.GEOSGeomGetPointN = null

  /**
   * Return the N'th point of a LineString
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry, must be a LineString
   * @param {number} n - Index of desired point (zero based)
   * @returns {GEOSGeometry} A Point geometry. Caller must free with GEOSGeom_destroy() NULL on exception.
   * @alias module:geos
   */
  geos.GEOSGeomGetPointN_r = Module.cwrap('GEOSGeomGetPointN_r', 'number', ['number', 'number', 'number'])

  /**
   * Return the first point of a LineString
   * @param {GEOSGeometry} g - Input geometry, must be a LineString
   * @returns {GEOSGeometry} A Point geometry. Caller must free with GEOSGeom_destroy() NULL on exception.
   * @alias module:geos
   */
  geos.GEOSGeomGetStartPoint = null

  /**
   * Return the first point of a LineString
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry, must be a LineString
   * @returns {GEOSGeometry} A Point geometry. Caller must free with GEOSGeom_destroy() NULL on exception.
   * @alias module:geos
   */
  geos.GEOSGeomGetStartPoint_r = Module.cwrap('GEOSGeomGetStartPoint_r', 'number', ['number', 'number'])

  /**
   * Returns the X coordinate, for a Point input, or an exception otherwise.
   * @param {GEOSGeometry} g - Input Point geometry
   * @param {NumberPointer} x - Pointer to hold return value
   * @returns {number} 1 on success, 0 on exception
   * @alias module:geos
   */
  geos.GEOSGeomGetX = null

  /**
   * Returns the X coordinate, for a Point input, or an exception otherwise.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input Point geometry
   * @param {NumberPointer} x - Pointer to hold return value
   * @returns {number} 1 on success, 0 on exception
   * @alias module:geos
   */
  geos.GEOSGeomGetX_r = Module.cwrap('GEOSGeomGetX_r', 'number', ['number', 'number', 'number'])

  /**
   * Returns the Y coordinate, for a Point input, or an exception otherwise.
   * @param {GEOSGeometry} g - Input Point geometry
   * @param {NumberPointer} y - Pointer to hold return value
   * @returns {number} 1 on success, 0 on exception
   * @alias module:geos
   */
  geos.GEOSGeomGetY = null

  /**
   * Returns the Y coordinate, for a Point input, or an exception otherwise.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input Point geometry
   * @param {NumberPointer} y - Pointer to hold return value
   * @returns {number} 1 on success, 0 on exception
   * @alias module:geos
   */
  geos.GEOSGeomGetY_r = Module.cwrap('GEOSGeomGetY_r', 'number', ['number', 'number', 'number'])

  /**
   * Returns the Z coordinate, for a Point input, or an exception otherwise.
   * @param {GEOSGeometry} g - Input Point geometry
   * @param {NumberPointer} z - Pointer to hold return value
   * @returns {number} 1 on success, 0 on exception
   * @alias module:geos
   */
  geos.GEOSGeomGetZ = null

  /**
   * Returns the Z coordinate, for a Point input, or an exception otherwise.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input Point geometry
   * @param {NumberPointer} z - Pointer to hold return value
   * @returns {number} 1 on success, 0 on exception
   * @alias module:geos
   */
  geos.GEOSGeomGetZ_r = Module.cwrap('GEOSGeomGetZ_r', 'number', ['number', 'number', 'number'])

  /**
   * @param {GEOSGeometry} g -
   * @param {NumberPointer} size -
   * @returns {number} unsigned
   * @deprecated use GEOSWKBWriter and GEOSWKBWriter_writeHEX()
   * @alias module:geos
   */
  geos.GEOSGeomToHEX_buf = null

  /**
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g -
   * @param {NumberPointer} size -
   * @returns {number} unsigned
   * @deprecated use GEOSWKBWriter and GEOSWKBWriter_writeHEX_r()
   * @alias module:geos
   */
  geos.GEOSGeomToHEX_buf_r = Module.cwrap('GEOSGeomToHEX_buf_r', 'number', ['number', 'number', 'number'])

  /**
   * @param {GEOSGeometry} g -
   * @param {NumberPointer} size -
   * @returns {number} unsigned
   * @deprecated use GEOSWKBWriter and GEOSWKBWriter_write()
   * @alias module:geos
   */
  geos.GEOSGeomToWKB_buf = null

  /**
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g -
   * @param {NumberPointer} size -
   * @returns {number} unsigned
   * @deprecated use GEOSWKBWriter and GEOSWKBWriter_write_r()
   * @alias module:geos
   */
  geos.GEOSGeomToWKB_buf_r = Module.cwrap('GEOSGeomToWKB_buf_r', 'number', ['number', 'number', 'number'])

  /**
   * @param {GEOSGeometry} g -
   * @returns {StringPointer} char*
   * @deprecated use GEOSWKTWriter and GEOSWKTWriter_write()
   * @alias module:geos
   */
  geos.GEOSGeomToWKT = null

  /**
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g -
   * @returns {StringPointer} char*
   * @deprecated use GEOSWKTWriter and GEOSWKTWriter_write_r()
   * @alias module:geos
   */
  geos.GEOSGeomToWKT_r = Module.cwrap('GEOSGeomToWKT_r', 'number', ['number', 'number'])

  /**
   * Returns the geometry type string for this geometry. eg: "GeometryCollection", "LineString"
   * @param {GEOSGeometry} g - Input geometry
   * @returns {StringPointer} A string with the geometry type. Caller must free with GEOSFree(). NULL on exception.
   * @alias module:geos
   */
  geos.GEOSGeomType = null

  /**
   * Returns the geometry type string for this geometry. eg: "GeometryCollection", "LineString"
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @returns {StringPointer} A string with the geometry type. Caller must free with GEOSFree(). NULL on exception.
   * @alias module:geos
   */
  geos.GEOSGeomType_r = Module.cwrap('GEOSGeomType_r', 'number', ['number', 'number'])

  /**
   * Returns the GEOSGeomTypeId number for this geometry.
   * @param {GEOSGeometry} g - Input geometry
   * @returns {number} The geometry type number, or -1 on exception.
   * @alias module:geos
   */
  geos.GEOSGeomTypeId = null

  /**
   * Returns the GEOSGeomTypeId number for this geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @returns {number} The geometry type number, or -1 on exception.
   * @alias module:geos
   */
  geos.GEOSGeomTypeId_r = Module.cwrap('GEOSGeomTypeId_r', 'number', ['number', 'number'])

  /**
   * Returns a point at the center of mass of the input.
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} A point at the center of mass of the input Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGetCentroid = null

  /**
   * Returns a point at the center of mass of the input.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} A point at the center of mass of the input Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSGetCentroid_r = Module.cwrap('GEOSGetCentroid_r', 'number', ['number', 'number'])

  /**
   * Get the external ring of a Polygon.
   * @param {GEOSGeometry} g - Input Polygon geometry
   * @returns {number} LinearRing geometry. Owned by parent geometry, do not free. NULL on exception.
   * @alias module:geos
   */
  geos.GEOSGetExteriorRing = null

  /**
   * Get the external ring of a Polygon.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input Polygon geometry
   * @returns {number} LinearRing geometry. Owned by parent geometry, do not free. NULL on exception.
   * @alias module:geos
   */
  geos.GEOSGetExteriorRing_r = Module.cwrap('GEOSGetExteriorRing_r', 'number', ['number', 'number'])

  /**
   * Returns the specified sub-geometry of a collection. For a simple geometry, returns a pointer to the input. Returned object is a pointer to internal storage: it must NOT be destroyed directly.
   * @param {GEOSGeometry} g - Input geometry
   * @param {number} n - Sub-geometry index, zero-based
   * @returns {number} A const GEOSGeometry, do not free! It will be freed when the parent is freed. Returns NULL on exception.
   * @alias module:geos
   */
  geos.GEOSGetGeometryN = null

  /**
   * Returns the specified sub-geometry of a collection. For a simple geometry, returns a pointer to the input. Returned object is a pointer to internal storage: it must NOT be destroyed directly.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @param {number} n - Sub-geometry index, zero-based
   * @returns {number} A const GEOSGeometry, do not free! It will be freed when the parent is freed. Returns NULL on exception.
   * @alias module:geos
   */
  geos.GEOSGetGeometryN_r = Module.cwrap('GEOSGetGeometryN_r', 'number', ['number', 'number', 'number'])

  /**
   * Returns the N'th ring for a Polygon input.
   * @param {GEOSGeometry} g - Input Polygon geometry
   * @param {number} n - Index of the desired ring
   * @returns {number} LinearRing geometry. Owned by parent geometry, do not free. NULL on exception.
   * @alias module:geos
   */
  geos.GEOSGetInteriorRingN = null

  /**
   * Returns the N'th ring for a Polygon input.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input Polygon geometry
   * @param {number} n - Index of the desired ring
   * @returns {number} LinearRing geometry. Owned by parent geometry, do not free. NULL on exception.
   * @alias module:geos
   */
  geos.GEOSGetInteriorRingN_r = Module.cwrap('GEOSGetInteriorRingN_r', 'number', ['number', 'number', 'number'])

  /**
   * Get the total number of points in a geometry, of any type.
   * @param {GEOSGeometry} g - Input geometry
   * @returns {number} Number of points in the geometry. -1 on exception.
   * @alias module:geos
   */
  geos.GEOSGetNumCoordinates = null

  /**
   * Get the total number of points in a geometry, of any type.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @returns {number} Number of points in the geometry. -1 on exception.
   * @alias module:geos
   */
  geos.GEOSGetNumCoordinates_r = Module.cwrap('GEOSGetNumCoordinates_r', 'number', ['number', 'number'])

  /**
   * Returns the number of sub-geometries immediately under a multi-geometry or collection or 1 for a simple geometry. For nested collections, remember to check if returned sub-geometries are themselves also collections. Empty collection or multi-geometry types return 0, and empty simple geometry types return 1.
   * @param {GEOSGeometry} g - Input geometry
   * @returns {number} Number of direct children in this collection
   * @alias module:geos
   */
  geos.GEOSGetNumGeometries = null

  /**
   * Returns the number of sub-geometries immediately under a multi-geometry or collection or 1 for a simple geometry. For nested collections, remember to check if returned sub-geometries are themselves also collections. Empty collection or multi-geometry types return 0, and empty simple geometry types return 1.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @returns {number} Number of direct children in this collection
   * @alias module:geos
   */
  geos.GEOSGetNumGeometries_r = Module.cwrap('GEOSGetNumGeometries_r', 'number', ['number', 'number'])

  /**
   * Returns the number of interior rings, for a Polygon input, or an exception otherwise.
   * @param {GEOSGeometry} g - Input Polygon geometry
   * @returns {number} Number of interior rings, -1 on exception
   * @alias module:geos
   */
  geos.GEOSGetNumInteriorRings = null

  /**
   * Returns the number of interior rings, for a Polygon input, or an exception otherwise.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input Polygon geometry
   * @returns {number} Number of interior rings, -1 on exception
   * @alias module:geos
   */
  geos.GEOSGetNumInteriorRings_r = Module.cwrap('GEOSGetNumInteriorRings_r', 'number', ['number', 'number'])

  /**
   * Returns the "spatial reference id" (SRID) for this geometry.
   * @param {GEOSGeometry} g - Input geometry
   * @returns {number} SRID number or 0 if unknown / not set.
   * @alias module:geos
   */
  geos.GEOSGetSRID = null

  /**
   * Returns the "spatial reference id" (SRID) for this geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @returns {number} SRID number or 0 if unknown / not set.
   * @alias module:geos
   */
  geos.GEOSGetSRID_r = Module.cwrap('GEOSGetSRID_r', 'number', ['number', 'number'])

  /**
   * Tests whether the input geometry has M coordinates.
   * @param {GEOSGeometry} g - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSHasM = null

  /**
   * Tests whether the input geometry has M coordinates.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSHasM_r = Module.cwrap('GEOSHasM_r', 'number', ['number', 'number'])

  /**
   * Tests whether the input geometry has Z coordinates.
   * @param {GEOSGeometry} g - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSHasZ = null

  /**
   * Tests whether the input geometry has Z coordinates.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSHasZ_r = Module.cwrap('GEOSHasZ_r', 'number', ['number', 'number'])

  /**
   * Calculate the Hausdorff distance between two geometries. Hausdorff distance is the largest distance between two geometries.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @param {NumberPointer} dist - Pointer to be filled in with distance result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSHausdorffDistance = null

  /**
   * Calculate the Hausdorff distance between two geometries. Hausdorff distance is the largest distance between two geometries.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @param {NumberPointer} dist - Pointer to be filled in with distance result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSHausdorffDistance_r = Module.cwrap('GEOSHausdorffDistance_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Calculate a more precise Hausdorff distance between two geometries, by densifying the inputs before computation. Hausdorff distance is the largest distance between two geometries.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @param {number} densifyFrac - The largest % of the overall line length that any given two-point segment should be
   * @param {NumberPointer} dist - Pointer to be filled in with distance result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSHausdorffDistanceDensify = null

  /**
   * Calculate a more precise Hausdorff distance between two geometries, by densifying the inputs before computation. Hausdorff distance is the largest distance between two geometries.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @param {number} densifyFrac - The largest % of the overall line length that any given two-point segment should be
   * @param {NumberPointer} dist - Pointer to be filled in with distance result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSHausdorffDistanceDensify_r = Module.cwrap('GEOSHausdorffDistanceDensify_r', 'number', ['number', 'number', 'number', 'number', 'number'])

  /**
   * Calculate the Hilbert code of the centroid of a geometry relative to an extent. This allows sorting geometries in a deterministic way, such that similar Hilbert codes are likely to be near each other in two-dimensional space. The caller must ensure that the geometry is contained within the extent.
   * @param {GEOSGeometry} geom - Input geometry, must be non-empty
   * @param {GEOSGeometry} extent - Extent within which to calculate the Hilbert code for geom
   * @param {number} level - The level of precision of the Hilbert curve, up to 16
   * @param {NumberPointer} code - Pointer to be filled in with Hilbert code result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSHilbertCode = null

  /**
   * Calculate the Hilbert code of the centroid of a geometry relative to an extent. This allows sorting geometries in a deterministic way, such that similar Hilbert codes are likely to be near each other in two-dimensional space. The caller must ensure that the geometry is contained within the extent.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} geom - Input geometry, must be non-empty
   * @param {GEOSGeometry} extent - Extent within which to calculate the Hilbert code for geom
   * @param {number} level - The level of precision of the Hilbert curve, up to 16
   * @param {NumberPointer} code - Pointer to be filled in with Hilbert code result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSHilbertCode_r = Module.cwrap('GEOSHilbertCode_r', 'number', ['number', 'number', 'number', 'number', 'number'])

  /**
   * Measuring from start of line, return point that is distance the start. Line parameter must be a LineString. The returned point is not guaranteed to intersect the line due to limitations of floating point calculations.
   * @param {GEOSGeometry} line - linear target of projection
   * @param {number} d - distance from start of line to created point
   * @returns {GEOSGeometry} The point GEOSGeometry that is distance from the start of line. Caller takes ownership of returned geometry.
   * @alias module:geos
   */
  geos.GEOSInterpolate = null

  /**
   * Measuring from start of line, return point that is distance the start. Line parameter must be a LineString. The returned point is not guaranteed to intersect the line due to limitations of floating point calculations.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} line - linear target of projection
   * @param {number} d - distance from start of line to created point
   * @returns {GEOSGeometry} The point GEOSGeometry that is distance from the start of line. Caller takes ownership of returned geometry.
   * @alias module:geos
   */
  geos.GEOSInterpolate_r = Module.cwrap('GEOSInterpolate_r', 'number', ['number', 'number', 'number'])

  /**
   * Measuring from start of line, return point that is a proportion the start. Line parameter must be a LineString.
   * @param {GEOSGeometry} line - linear target of projection
   * @param {number} proportion - The proportion from the start of line to created point
   * @returns {GEOSGeometry} The point GEOSGeometry that is distance from the start of line. Caller takes ownership of returned geometry.
   * @alias module:geos
   */
  geos.GEOSInterpolateNormalized = null

  /**
   * Measuring from start of line, return point that is a proportion the start. Line parameter must be a LineString.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - linear target of projection
   * @param {number} d - The proportion from the start of line to created point
   * @returns {GEOSGeometry} The point GEOSGeometry that is distance from the start of line. Caller takes ownership of returned geometry.
   * @alias module:geos
   */
  geos.GEOSInterpolateNormalized_r = Module.cwrap('GEOSInterpolateNormalized_r', 'number', ['number', 'number', 'number'])

  /**
   * Returns the intersection of two geometries: the set of points that fall within both geometries.
   * @param {GEOSGeometry} g1 - one of the geometries
   * @param {GEOSGeometry} g2 - the other geometry
   * @returns {GEOSGeometry} A newly allocated geometry of the intersection. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSIntersection = null

  /**
   * Returns the intersection of two geometries: the set of points that fall within both geometries.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - one of the geometries
   * @param {GEOSGeometry} g2 - the other geometry
   * @returns {GEOSGeometry} A newly allocated geometry of the intersection. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSIntersection_r = Module.cwrap('GEOSIntersection_r', 'number', ['number', 'number', 'number'])

  /**
   * Returns the intersection of two geometries: the set of points that fall within both geometries. All the vertices of the output geometry must fall on the grid defined by the gridSize, and the output will be a valid geometry.
   * @param {GEOSGeometry} g1 - one of the geometries
   * @param {GEOSGeometry} g2 - the other geometry
   * @param {number} gridSize - the cell size of the precision grid
   * @returns {GEOSGeometry} A newly allocated geometry of the intersection. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSIntersectionPrec = null

  /**
   * Returns the intersection of two geometries: the set of points that fall within both geometries. All the vertices of the output geometry must fall on the grid defined by the gridSize, and the output will be a valid geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - one of the geometries
   * @param {GEOSGeometry} g2 - the other geometry
   * @param {number} gridSize - the cell size of the precision grid
   * @returns {GEOSGeometry} A newly allocated geometry of the intersection. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSIntersectionPrec_r = Module.cwrap('GEOSIntersectionPrec_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Tests if two geometries intersect.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSIntersects = null

  /**
   * Tests if two geometries intersect.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSIntersects_r = Module.cwrap('GEOSIntersects_r', 'number', ['number', 'number', 'number'])

  /**
   * Tests whether the input geometry is closed. A closed geometry is a linestring or multilinestring with the start and end points being the same.
   * @param {GEOSGeometry} g - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSisClosed = null

  /**
   * Tests whether the input geometry is closed. A closed geometry is a linestring or multilinestring with the start and end points being the same.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSisClosed_r = Module.cwrap('GEOSisClosed_r', 'number', ['number', 'number'])

  /**
   * Tests whether the input geometry is empty. If the geometry or any component is non-empty, the geometry is non-empty. An empty geometry has no boundary or interior.
   * @param {GEOSGeometry} g - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSisEmpty = null

  /**
   * Tests whether the input geometry is empty. If the geometry or any component is non-empty, the geometry is non-empty. An empty geometry has no boundary or interior.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSisEmpty_r = Module.cwrap('GEOSisEmpty_r', 'number', ['number', 'number'])

  /**
   * Tests whether the input geometry is a ring. Rings are linestrings, without self-intersections, with start and end point being identical.
   * @param {GEOSGeometry} g - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSisRing = null

  /**
   * Tests whether the input geometry is a ring. Rings are linestrings, without self-intersections, with start and end point being identical.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSisRing_r = Module.cwrap('GEOSisRing_r', 'number', ['number', 'number'])

  /**
   * Tests whether the input geometry is "simple". Mostly relevant for linestrings. A "simple" linestring has no self-intersections.
   * @param {GEOSGeometry} g - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSisSimple = null

  /**
   * Tests whether the input geometry is "simple". Mostly relevant for linestrings. A "simple" linestring has no self-intersections.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSisSimple_r = Module.cwrap('GEOSisSimple_r', 'number', ['number', 'number'])

  /**
   * Check the validity of the provided geometry.
   * @param {GEOSGeometry} g - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSisValid = null

  /**
   * Check the validity of the provided geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSisValid_r = Module.cwrap('GEOSisValid_r', 'number', ['number', 'number'])

  /**
   * In one step, calculate and return the validity, the human readable validity reason and a point at which validity rules are broken. Caller has the responsibility to destroy 'reason' with GEOSFree() and 'location' with GEOSGeom_destroy()
   * @param {GEOSGeometry} g - The geometry to test
   * @param {number} flags - A value from the GEOSValidFlags enum
   * @param {Pointer} reason - A pointer in which the reason string will be places
   * @param {GEOSGeometry} location - A pointer in which the location GEOSGeometry will be placed
   * @returns {number} 1 when valid, 0 when invalid, 2 on exception
   * @alias module:geos
   */
  geos.GEOSisValidDetail = null

  /**
   * In one step, calculate and return the validity, the human readable validity reason and a point at which validity rules are broken. Caller has the responsibility to destroy 'reason' with GEOSFree() and 'location' with GEOSGeom_destroy()
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The geometry to test
   * @param {number} flags - A value from the GEOSValidFlags enum
   * @param {Pointer} reason - A pointer in which the reason string will be places
   * @param {GEOSGeometry} location - A pointer in which the location GEOSGeometry will be placed
   * @returns {number} 1 when valid, 0 when invalid, 2 on exception
   * @alias module:geos
   */
  geos.GEOSisValidDetail_r = Module.cwrap('GEOSisValidDetail_r', 'number', ['number', 'number', 'number', 'number', 'number'])

  /**
   * Return the human readable reason a geometry is invalid, "Valid Geometry" string otherwise, or NULL on exception.
   * @param {GEOSGeometry} g - The geometry to test
   * @returns {StringPointer} A string with the reason, NULL on exception. Caller must GEOSFree() their result.
   * @alias module:geos
   */
  geos.GEOSisValidReason = null

  /**
   * Return the human readable reason a geometry is invalid, "Valid Geometry" string otherwise, or NULL on exception.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The geometry to test
   * @returns {StringPointer} A string with the reason, NULL on exception. Caller must GEOSFree() their result.
   * @alias module:geos
   */
  geos.GEOSisValidReason_r = Module.cwrap('GEOSisValidReason_r', 'number', ['number', 'number'])

  /**
   * Constructs the "largest empty circle" (LEC) for a set of obstacle geometries and within a polygonal boundary, with accuracy to to a specified distance tolerance. The obstacles may be any collection of points, lines and polygons. The LEC is the largest circle whose interior does not intersect with any obstacle. and which has its center inside the given boundary. If no boundary is provided, the convex hull of the obstacles is used. The LEC center is the point in the interior of the boundary which has the farthest distance from the obstacles (up to the given distance tolerance). The LEC is determined by the center point and a point indicating the circle radius (which will lie on an obstacle).
   * To compute an LEC which lies wholly within a polygonal boundary, include the boundary of the polygon(s) as a linear obstacle.
   * The implementation uses a successive-approximation technique over a grid of square cells covering the obstacles and boundary. The grid is refined using a branch-and-bound algorithm. Point containment and distance are computed in a performant way by using spatial indexes.
   * Returns the LEC radius as a two-point linestring, with the start point at the center of the inscribed circle and the end on the boundary of the circle.
   * @param {GEOSGeometry} obstacles - The geometries that the LEC must not cross
   * @param {GEOSGeometry} boundary - The area to contain the LEC center (may be null or empty)
   * @param {number} tolerance - Stop the algorithm when the search area is smaller than this tolerance
   * @returns {GEOSGeometry} A newly allocated geometry of the LEC radius line. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSLargestEmptyCircle = null

  /**
   * Constructs the "largest empty circle" (LEC) for a set of obstacle geometries and within a polygonal boundary, with accuracy to to a specified distance tolerance. The obstacles may be any collection of points, lines and polygons. The LEC is the largest circle whose interior does not intersect with any obstacle. and which has its center inside the given boundary. If no boundary is provided, the convex hull of the obstacles is used. The LEC center is the point in the interior of the boundary which has the farthest distance from the obstacles (up to the given distance tolerance). The LEC is determined by the center point and a point indicating the circle radius (which will lie on an obstacle).
   * To compute an LEC which lies wholly within a polygonal boundary, include the boundary of the polygon(s) as a linear obstacle.
   * The implementation uses a successive-approximation technique over a grid of square cells covering the obstacles and boundary. The grid is refined using a branch-and-bound algorithm. Point containment and distance are computed in a performant way by using spatial indexes.
   * Returns the LEC radius as a two-point linestring, with the start point at the center of the inscribed circle and the end on the boundary of the circle.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The geometries that the LEC must not cross
   * @param {GEOSGeometry} boundary - The area to contain the LEC center (may be null or empty)
   * @param {number} tolerance - Stop the algorithm when the search area is smaller than this tolerance
   * @returns {GEOSGeometry} A newly allocated geometry of the LEC radius line. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSLargestEmptyCircle_r = Module.cwrap('GEOSLargestEmptyCircle_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Calculate the length of a geometry.
   * @param {GEOSGeometry} g - Input geometry
   * @param {NumberPointer} length - Pointer to be filled in with length result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSLength = null

  /**
   * Calculate the length of a geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @param {NumberPointer} length - Pointer to be filled in with length result
   * @returns {number} 1 on success, 0 on exception.
   * @alias module:geos
   */
  geos.GEOSLength_r = Module.cwrap('GEOSLength_r', 'number', ['number', 'number', 'number'])

  /**
   * Merges a set of LineStrings, joining them at nodes which have cardinality 2. Lines may have their direction reversed.
   * @param {GEOSGeometry} g - The input linework
   * @returns {GEOSGeometry} The merged linework. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSLineMerge = null

  /**
   * Merges a set of LineStrings, joining them at nodes which have cardinality 2. Lines may have their direction reversed.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input linework
   * @returns {GEOSGeometry} The merged linework. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSLineMerge_r = Module.cwrap('GEOSLineMerge_r', 'number', ['number', 'number'])

  /**
   * Merges a set of LineStrings, joining them at nodes which have cardinality 2. and where the lines have the same direction. This means that lines do not have their direction reversed.
   * @param {GEOSGeometry} g - The input linework
   * @returns {GEOSGeometry} The merged linework. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSLineMergeDirected = null

  /**
   * Merges a set of LineStrings, joining them at nodes which have cardinality 2. and where the lines have the same direction. This means that lines do not have their direction reversed.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input linework
   * @returns {GEOSGeometry} The merged linework. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSLineMergeDirected_r = Module.cwrap('GEOSLineMergeDirected_r', 'number', ['number', 'number'])

  /**
   * Computes the line which is the section of the input LineString starting and ending at the given length fractions.
   * @param {GEOSGeometry} g - The input LineString
   * @param {number} start_fraction - start fraction (0-1) along the length of g
   * @param {number} end_fraction - end fraction (0-1) along the length of g
   * @returns {GEOSGeometry} selected substring. Caller is responsible for freeing with GEOSGeom_destroy()
   * @alias module:geos
   */
  geos.GEOSLineSubstring = null

  /**
   * Computes the line which is the section of the input LineString starting and ending at the given length fractions.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input LineString
   * @param {number} start_fraction - start fraction (0-1) along the length of g
   * @param {number} end_fdraction - end fraction (0-1) along the length of g
   * @returns {GEOSGeometry} selected substring. Caller is responsible for freeing with GEOSGeom_destroy()
   * @alias module:geos
   */
  geos.GEOSLineSubstring_r = Module.cwrap('GEOSLineSubstring_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Repair an invalid geometry, returning a valid output.
   * @param {GEOSGeometry} g - The geometry to repair
   * @returns {GEOSGeometry} The repaired geometry. Caller must free with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSMakeValid = null

  /**
   * Repair an invalid geometry, returning a valid output.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The geometry to repair
   * @returns {GEOSGeometry} The repaired geometry. Caller must free with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSMakeValid_r = Module.cwrap('GEOSMakeValid_r', 'number', ['number', 'number'])

  /**
   * Create a GEOSMakeValidParams to hold the desired parameters to control the algorithm and behavior of the validation process.
   * @returns {GEOSMakeValidParams} a parameter object
   * @alias module:geos
   */
  geos.GEOSMakeValidParams_create = null

  /**
   * Create a GEOSMakeValidParams to hold the desired parameters to control the algorithm and behavior of the validation process.
   * @param {GEOSContextHandle_t} extHandle -
   * @returns {GEOSMakeValidParams} a parameter object
   * @alias module:geos
   */
  geos.GEOSMakeValidParams_create_r = Module.cwrap('GEOSMakeValidParams_create_r', 'number', ['number'])

  /**
   * Destroy a GEOSMakeValidParams.
   * @param {GEOSMakeValidParams} parms - the object to destroy
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSMakeValidParams_destroy = null

  /**
   * Destroy a GEOSMakeValidParams.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSMakeValidParams} parms - the object to destroy
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSMakeValidParams_destroy_r = Module.cwrap('GEOSMakeValidParams_destroy_r', 'null', ['number', 'number'])

  /**
   * When this parameter is nn-zero, the GEOS_MAKE_VALID_STRUCTURE method will keep components that have collapsed into a lower dimensionality. For example, a ring collapsing to a line, or a line collapsing to a point.
   * @param {GEOSMakeValidParams} p -
   * @param {number} keepCollapsed -
   * @returns {number} 0 on exception, 1 on success.
   * @alias module:geos
   */
  geos.GEOSMakeValidParams_setKeepCollapsed = null

  /**
   * When this parameter is nn-zero, the GEOS_MAKE_VALID_STRUCTURE method will keep components that have collapsed into a lower dimensionality. For example, a ring collapsing to a line, or a line collapsing to a point.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSMakeValidParams} p -
   * @param {number} style -
   * @returns {number} 0 on exception, 1 on success.
   * @alias module:geos
   */
  geos.GEOSMakeValidParams_setKeepCollapsed_r = Module.cwrap('GEOSMakeValidParams_setKeepCollapsed_r', 'number', ['number', 'number', 'number'])

  /**
   * Set the GEOSMakeValidMethods to use in making the geometry valid.
   * @param {GEOSMakeValidParams} p -
   * @param {GEOSMakeValidMethods} method -
   * @returns {number} 0 on exception, 1 on success.
   * @alias module:geos
   */
  geos.GEOSMakeValidParams_setMethod = null

  /**
   * Set the GEOSMakeValidMethods to use in making the geometry valid.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSMakeValidParams} p -
   * @param {GEOSMakeValidMethods} method -
   * @returns {number} 0 on exception, 1 on success.
   * @alias module:geos
   */
  geos.GEOSMakeValidParams_setMethod_r = Module.cwrap('GEOSMakeValidParams_setMethod_r', 'number', ['number', 'number', 'number'])

  /**
   * Repair an invalid geometry, returning a valid output, using the indicated GEOSMakeValidMethods algorithm and options.
   * @param {GEOSGeometry} g - is the geometry to test.
   * @param {GEOSMakeValidParams} makeValidParams - is a GEOSMakeValidParams with the desired parameters set on it.
   * @returns {GEOSGeometry} A repaired geometry. Caller must free with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSMakeValidWithParams = null

  /**
   * Repair an invalid geometry, returning a valid output, using the indicated GEOSMakeValidMethods algorithm and options.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - is the geometry to test.
   * @param {GEOSMakeValidParams} makeValidParams - is a GEOSMakeValidParams with the desired parameters set on it.
   * @returns {GEOSGeometry} A repaired geometry. Caller must free with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSMakeValidWithParams_r = Module.cwrap('GEOSMakeValidWithParams_r', 'number', ['number', 'number', 'number'])

  /**
   * Constructs the "maximum inscribed circle" (MIC) for a polygonal geometry, up to a specified tolerance. The MIC is determined by a point in the interior of the area which has the farthest distance from the area boundary, along with a boundary point at that distance. In the context of geography the center of the MIC is known as the "pole of inaccessibility". A cartographic use case is to determine a suitable point to place a map label within a polygon. The radius length of the MIC is a measure of how "narrow" a polygon is. It is the distance at which the negative buffer becomes empty. The class supports polygons with holes and multipolygons. The implementation uses a successive-approximation technique over a grid of square cells covering the area geometry. The grid is refined using a branch-and-bound algorithm. Point containment and distance are computed in a performant way by using spatial indexes. Returns a two-point linestring, with one point at the center of the inscribed circle and the other on the boundary of the inscribed circle.
   * @param {GEOSGeometry} g - Input geometry
   * @param {number} tolerance - Stop the algorithm when the search area is smaller than this tolerance
   * @returns {GEOSGeometry} A newly allocated geometry of the MIC. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSMaximumInscribedCircle = null

  /**
   * Constructs the "maximum inscribed circle" (MIC) for a polygonal geometry, up to a specified tolerance. The MIC is determined by a point in the interior of the area which has the farthest distance from the area boundary, along with a boundary point at that distance. In the context of geography the center of the MIC is known as the "pole of inaccessibility". A cartographic use case is to determine a suitable point to place a map label within a polygon. The radius length of the MIC is a measure of how "narrow" a polygon is. It is the distance at which the negative buffer becomes empty. The class supports polygons with holes and multipolygons. The implementation uses a successive-approximation technique over a grid of square cells covering the area geometry. The grid is refined using a branch-and-bound algorithm. Point containment and distance are computed in a performant way by using spatial indexes. Returns a two-point linestring, with one point at the center of the inscribed circle and the other on the boundary of the inscribed circle.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @param {number} tolerance - Stop the algorithm when the search area is smaller than this tolerance
   * @returns {GEOSGeometry} A newly allocated geometry of the MIC. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSMaximumInscribedCircle_r = Module.cwrap('GEOSMaximumInscribedCircle_r', 'number', ['number', 'number', 'number'])

  /**
   * Returns a geometry which represents the "minimum bounding circle", the smallest circle that contains the input.
   * @param {GEOSGeometry} g - The input geometry
   * @param {NumberPointer} radius - Pointer will be filled with output radius.
   * @param {GEOSGeometry} center - Pointer will be filled with output circle center. Caller must free.
   * @returns {GEOSGeometry} The circle geometry or NULL on exception Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSMinimumBoundingCircle = null

  /**
   * Returns a geometry which represents the "minimum bounding circle", the smallest circle that contains the input.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry
   * @param {NumberPointer} radius - Pointer will be filled with output radius.
   * @param {GEOSGeometry} center - Pointer will be filled with output circle center. Caller must free.
   * @returns {GEOSGeometry} The circle geometry or NULL on exception Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSMinimumBoundingCircle_r = Module.cwrap('GEOSMinimumBoundingCircle_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Computes the minimum clearance of a geometry. The minimum clearance is the smallest amount by which a vertex could be move to produce an invalid polygon, a non-simple linestring, or a multipoint with repeated points. If a geometry has a minimum clearance of 'eps', it can be said that:
   * @param {GEOSGeometry} g - the input geometry
   * @param {NumberPointer} d - a double to which the result can be stored
   * @returns {number} 0 if no exception occurred. 2 if an exception occurred.
   * @alias module:geos
   */
  geos.GEOSMinimumClearance = null

  /**
   * Computes the minimum clearance of a geometry. The minimum clearance is the smallest amount by which a vertex could be move to produce an invalid polygon, a non-simple linestring, or a multipoint with repeated points. If a geometry has a minimum clearance of 'eps', it can be said that:
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - the input geometry
   * @param {NumberPointer} distance - a double to which the result can be stored
   * @returns {number} 0 if no exception occurred. 2 if an exception occurred.
   * @alias module:geos
   */
  geos.GEOSMinimumClearance_r = Module.cwrap('GEOSMinimumClearance_r', 'number', ['number', 'number', 'number'])

  /**
   * Returns a LineString whose endpoints define the minimum clearance of a geometry. If the geometry has no minimum clearance, an empty LineString will be returned.
   * @param {GEOSGeometry} g - the input geometry
   * @returns {GEOSGeometry} a linestring geometry, or NULL if an exception occurred. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSMinimumClearanceLine = null

  /**
   * Returns a LineString whose endpoints define the minimum clearance of a geometry. If the geometry has no minimum clearance, an empty LineString will be returned.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - the input geometry
   * @returns {GEOSGeometry} a linestring geometry, or NULL if an exception occurred. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSMinimumClearanceLine_r = Module.cwrap('GEOSMinimumClearanceLine_r', 'number', ['number', 'number'])

  /**
   * Returns the minimum rotated rectangular POLYGON which encloses the input geometry. The rectangle has width equal to the minimum diameter, and a longer length. If the convex hill of the input is degenerate (a line or point) a linestring or point is returned. The minimum rotated rectangle can be used as an extremely generalized representation for the given geometry.
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} A newly allocated geometry of the rotated envelope. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSMinimumRotatedRectangle = null

  /**
   * Returns the minimum rotated rectangular POLYGON which encloses the input geometry. The rectangle has width equal to the minimum diameter, and a longer length. If the convex hill of the input is degenerate (a line or point) a linestring or point is returned. The minimum rotated rectangle can be used as an extremely generalized representation for the given geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} A newly allocated geometry of the rotated envelope. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSMinimumRotatedRectangle_r = Module.cwrap('GEOSMinimumRotatedRectangle_r', 'number', ['number', 'number'])

  /**
   * Returns a linestring geometry which represents the minimum diameter of the geometry. The minimum diameter is defined to be the width of the smallest band that contains the geometry, where a band is a strip of the plane defined by two parallel lines. This can be thought of as the smallest hole that the geometry can be moved through, with a single rotation.
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} A newly allocated geometry of the LEC. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSMinimumWidth = null

  /**
   * Returns a linestring geometry which represents the minimum diameter of the geometry. The minimum diameter is defined to be the width of the smallest band that contains the geometry, where a band is a strip of the plane defined by two parallel lines. This can be thought of as the smallest hole that the geometry can be moved through, with a single rotation.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} A newly allocated geometry of the LEC. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSMinimumWidth_r = Module.cwrap('GEOSMinimumWidth_r', 'number', ['number', 'number'])

  /**
   * The closest points of the two geometries. The first point comes from g1 geometry and the second point comes from g2.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {GEOSCoordSequence} A coordinate sequence with the two points, or NULL on exception. Caller must free with GEOSCoordSeq_destroy().
   * @alias module:geos
   */
  geos.GEOSNearestPoints = null

  /**
   * The closest points of the two geometries. The first point comes from g1 geometry and the second point comes from g2.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {GEOSCoordSequence} A coordinate sequence with the two points, or NULL on exception. Caller must free with GEOSCoordSeq_destroy().
   * @alias module:geos
   */
  geos.GEOSNearestPoints_r = Module.cwrap('GEOSNearestPoints_r', 'number', ['number', 'number', 'number'])

  /**
   * For linear inputs, returns a new geometry in which no lines cross each other, and all touching occurs at end points.
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} The noded geometry or NULL on exception Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSNode = null

  /**
   * For linear inputs, returns a new geometry in which no lines cross each other, and all touching occurs at end points.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} The noded geometry or NULL on exception Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSNode_r = Module.cwrap('GEOSNode_r', 'number', ['number', 'number'])

  /**
   * Organize the elements, rings, and coordinate order of geometries in a consistent way, so that geometries that represent the same object can be easily compared. Modifies the geometry in-place.
   * @param {GEOSGeometry} g - Input geometry
   * @returns {number} 0 on success or -1 on exception
   * @alias module:geos
   */
  geos.GEOSNormalize = null

  /**
   * Organize the elements, rings, and coordinate order of geometries in a consistent way, so that geometries that represent the same object can be easily compared. Modifies the geometry in-place.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @returns {number} 0 on success or -1 on exception
   * @alias module:geos
   */
  geos.GEOSNormalize_r = Module.cwrap('GEOSNormalize_r', 'number', ['number', 'number'])

  /**
   * Generates offset curve line(s) for a geometry. Handles all geometry types as input.
   * @param {GEOSGeometry} g - The linear geometry to offset from
   * @param {number} width - Distance to offset from the curve. Negative for a right-side offset. Positive for a left-side offset.
   * @param {number} quadsegs - Number of segments per quadrant
   * @param {number} joinStyle - See GEOSBufJoinStyles
   * @param {number} mitreLimit - See GEOSBufferParams_setMitreLimit
   * @returns {GEOSGeometry} The offset geometry. Returns NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSOffsetCurve = null

  /**
   * Generates offset curve line(s) for a geometry. Handles all geometry types as input.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The linear geometry to offset from
   * @param {number} width - Distance to offset from the curve. Negative for a right-side offset. Positive for a left-side offset.
   * @param {number} quadsegs - Number of segments per quadrant
   * @param {number} joinStyle - See GEOSBufJoinStyles
   * @param {number} mitreLimit - See GEOSBufferParams_setMitreLimit
   * @returns {GEOSGeometry} The offset geometry. Returns NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSOffsetCurve_r = Module.cwrap('GEOSOffsetCurve_r', 'number', ['number', 'number', 'number', 'number', 'number', 'number'])

  /**
   * For the points formed by the six input ordinates, walking from A to B and then to P.
   * @param {number} Ax - X coordinate of A
   * @param {number} Ay - Y coordinate of A
   * @param {number} Bx - X coordinate of B
   * @param {number} By - Y coordinate of B
   * @param {number} Px - X coordinate of P
   * @param {number} Py - Y coordinate of P
   * @returns {number} -1 if reaching P takes a counter-clockwise (left) turn, 1 if reaching P takes a clockwise (right) turn, 0 if P is collinear with A-B
   * @alias module:geos
   */
  geos.GEOSOrientationIndex = null

  /**
   * For the points formed by the six input ordinates, walking from A to B and then to P.
   * @param {GEOSContextHandle_t} handle -
   * @param {number} Ax - X coordinate of A
   * @param {number} Ay - Y coordinate of A
   * @param {number} Bx - X coordinate of B
   * @param {number} By - Y coordinate of B
   * @param {number} Px - X coordinate of P
   * @param {number} Py - Y coordinate of P
   * @returns {number} -1 if reaching P takes a counter-clockwise (left) turn, 1 if reaching P takes a clockwise (right) turn, 0 if P is collinear with A-B
   * @alias module:geos
   */
  geos.GEOSOrientationIndex_r = Module.cwrap('GEOSOrientationIndex_r', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number'])

  /**
   * Enforce a ring orientation on all polygonal elements in the input geometry. Non-polygonal geometries will not be modified.
   * @param {GEOSGeometry} g - Input geometry
   * @param {number} exteriorCW - if 1, exterior rings will be clockwise and interior rings will be counter-clockwise
   * @returns {number} 0 on success or -1 on exception
   * @alias module:geos
   */
  geos.GEOSOrientPolygons = null

  /**
   * Enforce a ring orientation on all polygonal elements in the input geometry. Non-polygonal geometries will not be modified.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @param {number} exteriorCW - if 1, exterior rings will be clockwise and interior rings will be counter-clockwise
   * @returns {number} 0 on success or -1 on exception
   * @alias module:geos
   */
  geos.GEOSOrientPolygons_r = Module.cwrap('GEOSOrientPolygons_r', 'number', ['number', 'number', 'number'])

  /**
   * Tests if two geometries share interiors but are neither within nor contained.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSOverlaps = null

  /**
   * Tests if two geometries share interiors but are neither within nor contained.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSOverlaps_r = Module.cwrap('GEOSOverlaps_r', 'number', ['number', 'number', 'number'])

  /**
   * Returns a point that is inside the boundary of a polygonal geometry.
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} A point that is inside the input Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSPointOnSurface = null

  /**
   * Returns a point that is inside the boundary of a polygonal geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} A point that is inside the input Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSPointOnSurface_r = Module.cwrap('GEOSPointOnSurface_r', 'number', ['number', 'number'])

  /**
   * Computes a boundary-respecting hull of a polygonal geometry, with hull shape determined by a target parameter specifying the fraction of the input vertices retained in the result. Larger values produce less concave results. A value of 1 produces the convex hull; a value of 0 produces the original geometry. An outer hull is computed if the parameter is positive, an inner hull is computed if it is negative.
   * @param {GEOSGeometry} g - the polygonal geometry to process
   * @param {number} isOuter - indicates whether to compute an outer or inner hull (1 for outer hull, 0 for inner)
   * @param {number} vertexNumFraction - the target fraction of the count of input vertices to retain in result
   * @returns {GEOSGeometry} A newly allocated geometry of the concave hull. NULL on exception.
   * @alias module:geos
   */
  geos.GEOSPolygonHullSimplify = null

  /**
   * Computes a boundary-respecting hull of a polygonal geometry, with hull shape determined by a target parameter specifying the fraction of the input vertices retained in the result. Larger values produce less concave results. A value of 1 produces the convex hull; a value of 0 produces the original geometry. An outer hull is computed if the parameter is positive, an inner hull is computed if it is negative.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - the polygonal geometry to process
   * @param {number} isOuter - indicates whether to compute an outer or inner hull (1 for outer hull, 0 for inner)
   * @param {number} vertexNumFraction - the target fraction of the count of input vertices to retain in result
   * @returns {GEOSGeometry} A newly allocated geometry of the concave hull. NULL on exception.
   * @alias module:geos
   */
  geos.GEOSPolygonHullSimplify_r = Module.cwrap('GEOSPolygonHullSimplify_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Computes a topology-preserving simplified hull of a polygonal geometry, with hull shape determined by the parameter, controlled by a parameter mode, which is one defined in GEOSPolygonHullParameterModes. Larger values compute less concave results and a value of 0 produces the original geometry. Either outer or inner hulls can be computed.
   * @param {GEOSGeometry} g - the polygonal geometry to process
   * @param {number} isOuter - indicates whether to compute an outer or inner hull (1 for outer hull, 0 for inner)
   * @param {number} parameterMode - the interpretation to apply to the parameter argument; see GEOSPolygonHullParameterModes
   * @param {number} parameter - the target ratio of area difference to original area
   * @returns {GEOSGeometry} A newly allocated geometry of the concave hull. NULL on exception.
   * @alias module:geos
   */
  geos.GEOSPolygonHullSimplifyMode = null

  /**
   * Computes a topology-preserving simplified hull of a polygonal geometry, with hull shape determined by the parameter, controlled by a parameter mode, which is one defined in GEOSPolygonHullParameterModes. Larger values compute less concave results and a value of 0 produces the original geometry. Either outer or inner hulls can be computed.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - the polygonal geometry to process
   * @param {number} isOuter - indicates whether to compute an outer or inner hull (1 for outer hull, 0 for inner)
   * @param {number} parameterMode - the interpretation to apply to the parameter argument; see GEOSPolygonHullParameterModes
   * @param {number} parameter - the target ratio of area difference to original area
   * @returns {GEOSGeometry} A newly allocated geometry of the concave hull. NULL on exception.
   * @alias module:geos
   */
  geos.GEOSPolygonHullSimplifyMode_r = Module.cwrap('GEOSPolygonHullSimplifyMode_r', 'number', ['number', 'number', 'number', 'number', 'number'])

  /**
   * Polygonizes a set of Geometries which contain linework that represents the edges of a planar graph.
   * @param {GEOSGeometry} geoms - Array of linear geometries to polygons. Caller retains ownersihp of both array container and objects.
   * @param {number} ngeoms - Size of the geoms array.
   * @returns {GEOSGeometry} The polygonal output geometry. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSPolygonize = null

  /**
   * Perform the polygonization as GEOSPolygonize() and return the polygonal result as well as all extra outputs.
   * @param {GEOSGeometry} input - A single geometry with all the input lines to polygonize.
   * @param {GEOSGeometry} cuts - Pointer to hold "cut edges", connected on both ends but not part of output. Caller must free.
   * @param {GEOSGeometry} dangles - Pointer to hold "dangles", connected one end but not part of output. Caller must free.
   * @param {GEOSGeometry} invalid - Pointer to hold invalid outputs, polygons formed but not valid. Caller must free.
   * @returns {GEOSGeometry} The polygonal valid output Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSPolygonize_full = null

  /**
   * Perform the polygonization as GEOSPolygonize() and return the polygonal result as well as all extra outputs.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} input - A single geometry with all the input lines to polygonize.
   * @param {GEOSGeometry} cuts - Pointer to hold "cut edges", connected on both ends but not part of output. Caller must free.
   * @param {GEOSGeometry} dangles - Pointer to hold "dangles", connected one end but not part of output. Caller must free.
   * @param {GEOSGeometry} invalidRings - Pointer to hold invalid outputs, polygons formed but not valid. Caller must free.
   * @returns {GEOSGeometry} The polygonal valid output Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSPolygonize_full_r = Module.cwrap('GEOSPolygonize_full_r', 'number', ['number', 'number', 'number', 'number', 'number'])

  /**
   * Polygonizes a set of Geometries which contain linework that represents the edges of a planar graph.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} geoms - Array of linear geometries to polygons. Caller retains ownersihp of both array container and objects.
   * @param {number} ngeoms - Size of the geoms array.
   * @returns {GEOSGeometry} The polygonal output geometry. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSPolygonize_r = Module.cwrap('GEOSPolygonize_r', 'number', ['number', 'number', 'number'])

  /**
   * Has the same polygonizing behavior as GEOSPolygonize(), but returns a result which is a valid polygonal geometry. The result will not contain any edge-adjacent elements.
   * @param {GEOSGeometry} geoms - Array of linear geometries to polygons. Caller retains ownersihp of both array container and objects.
   * @param {number} ngeoms - Size of the geoms array.
   * @returns {GEOSGeometry} The polygonal output geometry. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSPolygonize_valid = null

  /**
   * Has the same polygonizing behavior as GEOSPolygonize(), but returns a result which is a valid polygonal geometry. The result will not contain any edge-adjacent elements.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} geoms - Array of linear geometries to polygons. Caller retains ownersihp of both array container and objects.
   * @param {number} ngems - Size of the geoms array.
   * @returns {GEOSGeometry} The polygonal output geometry. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSPolygonize_valid_r = Module.cwrap('GEOSPolygonize_valid_r', 'number', ['number', 'number', 'number'])

  /**
   * Perform the polygonization as GEOSPolygonize() but return only the "cut edges", the linear features that are connected at both ends, do not participate in the final polygon.
   * @param {GEOSGeometry} geoms - Array of linear geometries to polygons. Caller retains ownersihp of both array container and objects.
   * @param {number} ngeoms - Size of the geoms array.
   * @returns {GEOSGeometry} The "cut edges" Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSPolygonizer_getCutEdges = null

  /**
   * Perform the polygonization as GEOSPolygonize() but return only the "cut edges", the linear features that are connected at both ends, do not participate in the final polygon.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} geoms - Array of linear geometries to polygons. Caller retains ownersihp of both array container and objects.
   * @param {number} ngeoms - Size of the geoms array.
   * @returns {GEOSGeometry} The "cut edges" Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSPolygonizer_getCutEdges_r = Module.cwrap('GEOSPolygonizer_getCutEdges_r', 'number', ['number', 'number', 'number'])

  /**
   * Create a Prepared Geometry. The caller retains ownership of the base geometry, and after processing is complete, must free both the prepared and the base geometry. (Ideally, destroy the prepared geometry first, as it has an internal reference to the base geometry.)
   * @param {GEOSGeometry} g - The base geometry to wrap in a prepared geometry.
   * @returns {number} A prepared geometry. Caller is responsible for freeing with GEOSPreparedGeom_destroy()
   * @alias module:geos
   */
  geos.GEOSPrepare = null

  /**
   * Create a Prepared Geometry. The caller retains ownership of the base geometry, and after processing is complete, must free both the prepared and the base geometry. (Ideally, destroy the prepared geometry first, as it has an internal reference to the base geometry.)
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The base geometry to wrap in a prepared geometry.
   * @returns {number} A prepared geometry. Caller is responsible for freeing with GEOSPreparedGeom_destroy()
   * @alias module:geos
   */
  geos.GEOSPrepare_r = Module.cwrap('GEOSPrepare_r', 'number', ['number', 'number'])

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry is contained.
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedContains = null

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry is contained.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedContains_r = Module.cwrap('GEOSPreparedContains_r', 'number', ['number', 'number', 'number'])

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry is contained properly.
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedContainsProperly = null

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry is contained properly.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedContainsProperly_r = Module.cwrap('GEOSPreparedContainsProperly_r', 'number', ['number', 'number', 'number'])

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation of whether the provided point is contained.
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {number} x - x coordinate of point to test
   * @param {number} y - y coordinate of point to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedContainsXY = null

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation of whether the provided point is contained.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {number} x - x coordinate of point to test
   * @param {number} y - y coordinate of point to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedContainsXY_r = Module.cwrap('GEOSPreparedContainsXY_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Using a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry is covered by.
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedCoveredBy = null

  /**
   * Using a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry is covered by.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedCoveredBy_r = Module.cwrap('GEOSPreparedCoveredBy_r', 'number', ['number', 'number', 'number'])

  /**
   * Using a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry covers.
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedCovers = null

  /**
   * Using a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry covers.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedCovers_r = Module.cwrap('GEOSPreparedCovers_r', 'number', ['number', 'number', 'number'])

  /**
   * Using a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry crosses.
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedCrosses = null

  /**
   * Using a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry crosses.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedCrosses_r = Module.cwrap('GEOSPreparedCrosses_r', 'number', ['number', 'number', 'number'])

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry is disjoint.
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedDisjoint = null

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry is disjoint.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedDisjoint_r = Module.cwrap('GEOSPreparedDisjoint_r', 'number', ['number', 'number', 'number'])

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation to find the distance between the prepared and provided geometry. Useful for situations where one geometry is large and static and needs to be tested against a large number of other geometries.
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @param {NumberPointer} dist - Pointer to store the result in
   * @returns {number} 1 on success
   * @alias module:geos
   */
  geos.GEOSPreparedDistance = null

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation to find the distance between the prepared and provided geometry. Useful for situations where one geometry is large and static and needs to be tested against a large number of other geometries.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @param {NumberPointer} dist - Pointer to store the result in
   * @returns {number} 1 on success
   * @alias module:geos
   */
  geos.GEOSPreparedDistance_r = Module.cwrap('GEOSPreparedDistance_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation to find whether the prepared and provided geometry are within the given max distance. Useful for situations where one geometry is large and static and needs to be tested against a large number of other geometries.
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @param {number} dist - The max distance
   * @returns {number} 1 on success
   * @alias module:geos
   */
  geos.GEOSPreparedDistanceWithin = null

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation to find whether the prepared and provided geometry are within the given max distance. Useful for situations where one geometry is large and static and needs to be tested against a large number of other geometries.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @param {number} dist - The max distance
   * @returns {number} 1 on success
   * @alias module:geos
   */
  geos.GEOSPreparedDistanceWithin_r = Module.cwrap('GEOSPreparedDistanceWithin_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Free the memory associated with a GEOSPreparedGeometry. Caller must separately free the base GEOSGeometry used to create the prepared geometry.
   * @param {GEOSPreparedGeometry} g - Prepared geometry to destroy.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSPreparedGeom_destroy = null

  /**
   * Free the memory associated with a GEOSPreparedGeometry. Caller must separately free the base GEOSGeometry used to create the prepared geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSPreparedGeometry} g - Prepared geometry to destroy.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSPreparedGeom_destroy_r = Module.cwrap('GEOSPreparedGeom_destroy_r', 'null', ['number', 'number'])

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry intersects.
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedIntersects = null

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry intersects.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedIntersects_r = Module.cwrap('GEOSPreparedIntersects_r', 'number', ['number', 'number', 'number'])

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation of whether the provided point intersects.
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {number} x - x coordinate of point to test
   * @param {number} y - y coordinate of point to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedIntersectsXY = null

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation of whether the provided point intersects.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {number} x - x coordinate of point to test
   * @param {number} y - y coordinate of point to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedIntersectsXY_r = Module.cwrap('GEOSPreparedIntersectsXY_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation to find the nearest points between the prepared and provided geometry.
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {GEOSCoordSequence} A coordinate sequence containing the nearest points, or NULL on exception. The first point in the sequence is from the prepared geometry, and the seconds is from the other argument.
   * @alias module:geos
   */
  geos.GEOSPreparedNearestPoints = null

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation to find the nearest points between the prepared and provided geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {GEOSCoordSequence} A coordinate sequence containing the nearest points, or NULL on exception. The first point in the sequence is from the prepared geometry, and the seconds is from the other argument.
   * @alias module:geos
   */
  geos.GEOSPreparedNearestPoints_r = Module.cwrap('GEOSPreparedNearestPoints_r', 'number', ['number', 'number', 'number'])

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry overlaps.
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedOverlaps = null

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry overlaps.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedOverlaps_r = Module.cwrap('GEOSPreparedOverlaps_r', 'number', ['number', 'number', 'number'])

  /**
   * Use a GEOSPreparedGeometry do a high-performance calculation of the DE9IM relationship between the prepared and provided geometry.
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {StringPointer} The DE9IM string
   * @alias module:geos
   */
  geos.GEOSPreparedRelate = null

  /**
   * Use a GEOSPreparedGeometry do a high-performance calculation of the DE9IM relationship between the prepared and provided geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {StringPointer} The DE9IM string
   * @alias module:geos
   */
  geos.GEOSPreparedRelate_r = Module.cwrap('GEOSPreparedRelate_r', 'number', ['number', 'number', 'number'])

  /**
   * Use a GEOSPreparedGeometry do a high-performance calculation of the DE9IM relationship between the prepared and provided geometry, and compare the relationship to the provided DE9IM pattern. Returns true if the patterns are consistent and false otherwise.
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @param {StringPointer} imPattern - The DE9IM pattern to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedRelatePattern = null

  /**
   * Use a GEOSPreparedGeometry do a high-performance calculation of the DE9IM relationship between the prepared and provided geometry, and compare the relationship to the provided DE9IM pattern. Returns true if the patterns are consistent and false otherwise.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @param {StringPointer} im - The DE9IM pattern to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedRelatePattern_r = Module.cwrap('GEOSPreparedRelatePattern_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry touches.
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedTouches = null

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry touches.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedTouches_r = Module.cwrap('GEOSPreparedTouches_r', 'number', ['number', 'number', 'number'])

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry is within.
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedWithin = null

  /**
   * Use a GEOSPreparedGeometry do a high performance calculation of whether the provided geometry is within.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSPreparedGeometry} pg1 - The prepared geometry
   * @param {GEOSGeometry} g2 - The geometry to test
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSPreparedWithin_r = Module.cwrap('GEOSPreparedWithin_r', 'number', ['number', 'number', 'number'])

  /**
   * Distance of point projected onto line from the start of the line.
   * @param {GEOSGeometry} line - linear target of projection
   * @param {GEOSGeometry} point - point to be projected onto 'g'
   * @returns {number} distance along line that point projects to, -1 on exception
   * @alias module:geos
   */
  geos.GEOSProject = null

  /**
   * Distance of point projected onto line from the start of the line.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} line - linear target of projection
   * @param {GEOSGeometry} point - point to be projected onto 'g'
   * @returns {number} distance along line that point projects to, -1 on exception
   * @alias module:geos
   */
  geos.GEOSProject_r = Module.cwrap('GEOSProject_r', 'number', ['number', 'number', 'number'])

  /**
   * Project point to line and calculate the proportion of the line the point is from the start. For example, a point that projects to the middle of a line would be return 0.5.
   * @param {GEOSGeometry} line - linear target of projection
   * @param {GEOSGeometry} point - the point to project
   * @returns {number} The proportion of the overall line length that the projected point falls at.
   * @alias module:geos
   */
  geos.GEOSProjectNormalized = null

  /**
   * Project point to line and calculate the proportion of the line the point is from the start. For example, a point that projects to the middle of a line would be return 0.5.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - linear target of projection
   * @param {GEOSGeometry} p - the point to project
   * @returns {number} The proportion of the overall line length that the projected point falls at.
   * @alias module:geos
   */
  geos.GEOSProjectNormalized_r = Module.cwrap('GEOSProjectNormalized_r', 'number', ['number', 'number', 'number'])

  /**
   * Calculate the DE9IM string for this geometry pair. The result is a 9-character string containing dimension symbols in the set "012F".
   * @param {GEOSGeometry} g1 - First geometry in pair
   * @param {GEOSGeometry} g2 - Second geometry in pair
   * @returns {StringPointer} DE9IM string. Caller is responsible for freeing with GEOSFree(). NULL on exception
   * @alias module:geos
   */
  geos.GEOSRelate = null

  /**
   * Calculate the DE9IM string for this geometry pair. The result is a 9-character string containing dimension symbols in the set "012F".
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - First geometry in pair
   * @param {GEOSGeometry} g2 - Second geometry in pair
   * @returns {StringPointer} DE9IM string. Caller is responsible for freeing with GEOSFree(). NULL on exception
   * @alias module:geos
   */
  geos.GEOSRelate_r = Module.cwrap('GEOSRelate_r', 'number', ['number', 'number', 'number'])

  /**
   * Calculate the DE9IM string for this geometry pair, using the supplied GEOSRelateBoundaryNodeRules.
   * @param {GEOSGeometry} g1 - First geometry in pair
   * @param {GEOSGeometry} g2 - Second geometry in pair
   * @param {number} bnr - A member of the GEOSRelateBoundaryNodeRules enum
   * @returns {StringPointer} DE9IM string. Caller is responsible for freeing with GEOSFree(). NULL on exception
   * @alias module:geos
   */
  geos.GEOSRelateBoundaryNodeRule = null

  /**
   * Calculate the DE9IM string for this geometry pair, using the supplied GEOSRelateBoundaryNodeRules.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - First geometry in pair
   * @param {GEOSGeometry} g2 - Second geometry in pair
   * @param {number} bnr - A member of the GEOSRelateBoundaryNodeRules enum
   * @returns {StringPointer} DE9IM string. Caller is responsible for freeing with GEOSFree(). NULL on exception
   * @alias module:geos
   */
  geos.GEOSRelateBoundaryNodeRule_r = Module.cwrap('GEOSRelateBoundaryNodeRule_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Calculate the DE9IM string for a geometry pair and compare against a DE9IM pattern. Returns true if the computed matrix matches the pattern. The pattern is a 9-character string containing symbols in the set "012TF*". "012F" match the corresponding dimension symbol; "T" matches any non-empty dimension; "*" matches any dimension.
   * @param {GEOSGeometry} g1 - First geometry in pair
   * @param {GEOSGeometry} g2 - Second geometry in pair
   * @param {StringPointer} imPattern - DE9IM pattern to match
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSRelatePattern = null

  /**
   * Calculate the DE9IM string for a geometry pair and compare against a DE9IM pattern. Returns true if the computed matrix matches the pattern. The pattern is a 9-character string containing symbols in the set "012TF*". "012F" match the corresponding dimension symbol; "T" matches any non-empty dimension; "*" matches any dimension.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - First geometry in pair
   * @param {GEOSGeometry} g2 - Second geometry in pair
   * @param {StringPointer} imPattern - DE9IM pattern to match
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSRelatePattern_r = Module.cwrap('GEOSRelatePattern_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Compare a DE9IM string to a pattern and return true if they are consistent.
   * @param {StringPointer} intMatrix - DE9IM string (contains symbols "012F")
   * @param {StringPointer} imPattern - Pattern to match to (may also contain symbols "T" and "*")
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSRelatePatternMatch = null

  /**
   * Compare a DE9IM string to a pattern and return true if they are consistent.
   * @param {GEOSContextHandle_t} handle -
   * @param {StringPointer} intMatrix - DE9IM string (contains symbols "012F")
   * @param {StringPointer} imPattern - Pattern to match to (may also contain symbols "T" and "*")
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSRelatePatternMatch_r = Module.cwrap('GEOSRelatePatternMatch_r', 'number', ['number', 'number', 'number'])

  /**
   * Works from start of each coordinate sequence in the geometry, retaining points that are further away from the previous retained point than the tolerance value.
   * @param {GEOSGeometry} g - The geometry to filter
   * @param {number} tolerance - Remove all points within this distance of each other. Use 0.0 to remove only exactly repeated points.
   * @returns {GEOSGeometry} A geometry with all points within the tolerance of each other removed.
   * @alias module:geos
   */
  geos.GEOSRemoveRepeatedPoints = null

  /**
   * Works from start of each coordinate sequence in the geometry, retaining points that are further away from the previous retained point than the tolerance value.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The geometry to filter
   * @param {number} tolerance - Remove all points within this distance of each other. Use 0.0 to remove only exactly repeated points.
   * @returns {GEOSGeometry} A geometry with all points within the tolerance of each other removed.
   * @alias module:geos
   */
  geos.GEOSRemoveRepeatedPoints_r = Module.cwrap('GEOSRemoveRepeatedPoints_r', 'number', ['number', 'number', 'number'])

  /**
   * For geometries with coordinate sequences, reverses the order of the sequences. Converts CCW rings to CW. Reverses direction of LineStrings.
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} The reversed geometry Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSReverse = null

  /**
   * For geometries with coordinate sequences, reverses the order of the sequences. Converts CCW rings to CW. Reverses direction of LineStrings.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} The reversed geometry Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSReverse_r = Module.cwrap('GEOSReverse_r', 'number', ['number', 'number'])

  /**
   * Computes the coordinate where two line segments intersect, if any
   * @param {number} ax0 - x-coordinate of 1st point in 1st segment
   * @param {number} ay0 - y-coordinate of 1st point in 1st segment
   * @param {number} ax1 - x-coordinate of 2nd point in 1st segment
   * @param {number} ay1 - y-coordinate of 2nd point in 1st segment
   * @param {number} bx0 - x-coordinate of 1st point in 2nd segment
   * @param {number} by0 - y-coordinate of 1st point in 2nd segment
   * @param {number} bx1 - x-coordinate of 2nd point in 2nd segment
   * @param {number} by1 - y-coordinate of 2nd point in 2nd segment
   * @param {NumberPointer} cx - x-coordinate of intersection point
   * @param {NumberPointer} cy - y-coordinate of intersection point
   * @returns {number} 0 on error, 1 on success, -1 if segments do not intersect
   * @alias module:geos
   */
  geos.GEOSSegmentIntersection = null

  /**
   * Computes the coordinate where two line segments intersect, if any
   * @param {GEOSContextHandle_t} extHandle -
   * @param {number} ax0 - x-coordinate of 1st point in 1st segment
   * @param {number} ay0 - y-coordinate of 1st point in 1st segment
   * @param {number} ax1 - x-coordinate of 2nd point in 1st segment
   * @param {number} ay1 - y-coordinate of 2nd point in 1st segment
   * @param {number} bx0 - x-coordinate of 1st point in 2nd segment
   * @param {number} by0 - y-coordinate of 1st point in 2nd segment
   * @param {number} bx1 - x-coordinate of 2nd point in 2nd segment
   * @param {number} by1 - y-coordinate of 2nd point in 2nd segment
   * @param {NumberPointer} cx - x-coordinate of intersection point
   * @param {NumberPointer} cy - y-coordinate of intersection point
   * @returns {number} 0 on error, 1 on success, -1 if segments do not intersect
   * @alias module:geos
   */
  geos.GEOSSegmentIntersection_r = Module.cwrap('GEOSSegmentIntersection_r', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number'])

  /**
   * Set the "spatial reference id" (SRID) for this geometry.
   * @param {GEOSGeometry} g - Input geometry
   * @param {number} SRID - SRID number or 0 for unknown SRID.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSSetSRID = null

  /**
   * Set the "spatial reference id" (SRID) for this geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - Input geometry
   * @param {number} SRID - SRID number or 0 for unknown SRID.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSSetSRID_r = Module.cwrap('GEOSSetSRID_r', 'null', ['number', 'number', 'number'])

  /**
   * Find paths shared between the two given lineal geometries.
   * @param {GEOSGeometry} g1 - An input geometry
   * @param {GEOSGeometry} g2 - An input geometry
   * @returns {GEOSGeometry} The shared paths Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSSharedPaths = null

  /**
   * Find paths shared between the two given lineal geometries.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - An input geometry
   * @param {GEOSGeometry} g2 - An input geometry
   * @returns {GEOSGeometry} The shared paths Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSSharedPaths_r = Module.cwrap('GEOSSharedPaths_r', 'number', ['number', 'number', 'number'])

  /**
   * Apply the Douglas/Peucker algorithm to the coordinate sequences of the input geometry. Removes "unnecessary" vertices, vertices that are co-linear within the tolerance distance.
   * @param {GEOSGeometry} g - The input geometry
   * @param {number} tolerance - The tolerance to apply. Larger tolerance leads to simpler output.
   * @returns {GEOSGeometry} The simplified geometry Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSSimplify = null

  /**
   * Apply the Douglas/Peucker algorithm to the coordinate sequences of the input geometry. Removes "unnecessary" vertices, vertices that are co-linear within the tolerance distance.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry
   * @param {number} tolerance - The tolerance to apply. Larger tolerance leads to simpler output.
   * @returns {GEOSGeometry} The simplified geometry Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSSimplify_r = Module.cwrap('GEOSSimplify_r', 'number', ['number', 'number', 'number'])

  /**
   * @param {GEOSGeometry} g -
   * @param {number} width -
   * @param {number} quadsegs -
   * @param {number} joinStyle -
   * @param {number} mitreLimit -
   * @param {number} leftSide -
   * @returns {GEOSGeometry} GEOSGeometry*
   * @deprecated in 3.3.0, use GEOSOffsetCurve() instead
   * @alias module:geos
   */
  geos.GEOSSingleSidedBuffer = null

  /**
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g -
   * @param {number} width -
   * @param {number} quadsegs -
   * @param {number} joinStyle -
   * @param {number} mitreLimit -
   * @param {number} leftSide -
   * @returns {GEOSGeometry} GEOSGeometry*
   * @deprecated in 3.3.0, use GEOSOffsetCurve() instead
   * @alias module:geos
   */
  geos.GEOSSingleSidedBuffer_r = Module.cwrap('GEOSSingleSidedBuffer_r', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number'])

  /**
   * Snaps the vertices and segments of the first geometry to vertices of the second geometry within the given tolerance.
   * @param {GEOSGeometry} input - An input geometry
   * @param {GEOSGeometry} snap_target - A geometry to snap the input to
   * @param {number} tolerance - Snapping tolerance
   * @returns {GEOSGeometry} The snapped version of the input. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSSnap = null

  /**
   * Snaps the vertices and segments of the first geometry to vertices of the second geometry within the given tolerance.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - An input geometry
   * @param {GEOSGeometry} g2 - A geometry to snap the input to
   * @param {number} tolerance - Snapping tolerance
   * @returns {GEOSGeometry} The snapped version of the input. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSSnap_r = Module.cwrap('GEOSSnap_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Construct an STRtree from items that have been inserted. Once constructed, no more items may be inserted into the tree. Functions that require a constructed tree will build it automatically, so there is no need to call GEOSSTRtree_build unless it is desired to explicitly construct the tree in a certain section of code or using a certain thread.
   * @param {GEOSSTRtree} tree - the GEOSSTRtree to apply the build to
   * @returns {number} 1 on success, 0 on error
   * @alias module:geos
   */
  geos.GEOSSTRtree_build = null

  /**
   * Construct an STRtree from items that have been inserted. Once constructed, no more items may be inserted into the tree. Functions that require a constructed tree will build it automatically, so there is no need to call GEOSSTRtree_build unless it is desired to explicitly construct the tree in a certain section of code or using a certain thread.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSSTRtree} tree - the GEOSSTRtree to apply the build to
   * @returns {number} 1 on success, 0 on error
   * @alias module:geos
   */
  geos.GEOSSTRtree_build_r = Module.cwrap('GEOSSTRtree_build_r', 'number', ['number', 'number'])

  /**
   * Create a new GEOSSTRtree using the Sort-Tile-Recursive algorithm (STRtree) for two-dimensional spatial data.
   * @param {number} nodeCapacity - The maximum number of child nodes that a node may have. The minimum recommended capacity value is 4. If unsure, use a default node capacity of 10.
   * @returns {GEOSSTRtree} a pointer to the created tree
   * @alias module:geos
   */
  geos.GEOSSTRtree_create = null

  /**
   * Create a new GEOSSTRtree using the Sort-Tile-Recursive algorithm (STRtree) for two-dimensional spatial data.
   * @param {GEOSContextHandle_t} handle -
   * @param {number} nodeCapacity - The maximum number of child nodes that a node may have. The minimum recommended capacity value is 4. If unsure, use a default node capacity of 10.
   * @returns {GEOSSTRtree} a pointer to the created tree
   * @alias module:geos
   */
  geos.GEOSSTRtree_create_r = Module.cwrap('GEOSSTRtree_create_r', 'number', ['number', 'number'])

  /**
   * Frees all the memory associated with a GEOSSTRtree. Only the tree is freed. The geometries and items fed into GEOSSTRtree_insert() are not owned by the tree, and are still left to the caller to manage.
   * @param {GEOSSTRtree} tree - the GEOSSTRtree to destroy
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSSTRtree_destroy = null

  /**
   * Frees all the memory associated with a GEOSSTRtree. Only the tree is freed. The geometries and items fed into GEOSSTRtree_insert() are not owned by the tree, and are still left to the caller to manage.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSSTRtree} tree - the GEOSSTRtree to destroy
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSSTRtree_destroy_r = Module.cwrap('GEOSSTRtree_destroy_r', 'null', ['number', 'number'])

  /**
   * Insert an item into an GEOSSTRtree
   * @param {GEOSSTRtree} tree - the GEOSSTRtree in which the item should be inserted
   * @param {GEOSGeometry} g - a GEOSGeometry whose envelope corresponds to the extent of 'item'. As of GEOS 3.9, this envelope will be copied into the tree and the caller may destroy g while the tree is still in use. Before GEOS 3.9, g must be retained until the tree is destroyed.
   * @param {Pointer} item - the item to insert into the tree
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSSTRtree_insert = null

  /**
   * Insert an item into an GEOSSTRtree
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSSTRtree} tree - the GEOSSTRtree in which the item should be inserted
   * @param {GEOSGeometry} g - a GEOSGeometry whose envelope corresponds to the extent of 'item'. As of GEOS 3.9, this envelope will be copied into the tree and the caller may destroy g while the tree is still in use. Before GEOS 3.9, g must be retained until the tree is destroyed.
   * @param {Pointer} item - the item to insert into the tree
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSSTRtree_insert_r = Module.cwrap('GEOSSTRtree_insert_r', 'null', ['number', 'number', 'number', 'number'])

  /**
   * Iterate over all items in the GEOSSTRtree. This will not cause the tree to be constructed.
   * @param {GEOSSTRtree} tree - the STRtree over which to iterate
   * @param {GEOSQueryCallback} callback - a function to be executed for each item in the tree.
   * @param {Pointer} userdata - payload to pass the callback function.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSSTRtree_iterate = null

  /**
   * Iterate over all items in the GEOSSTRtree. This will not cause the tree to be constructed.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSSTRtree} tree - the STRtree over which to iterate
   * @param {GEOSQueryCallback} callback - a function to be executed for each item in the tree.
   * @param {Pointer} userdata - payload to pass the callback function.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSSTRtree_iterate_r = Module.cwrap('GEOSSTRtree_iterate_r', 'null', ['number', 'number', 'number', 'number'])

  /**
   * Returns the nearest item in the GEOSSTRtree to the supplied geometry. All items in the tree MUST be of type GEOSGeometry. If this is not the case, use GEOSSTRtree_nearest_generic() instead. The tree will automatically be constructed if necessary, after which no more items may be added.
   * @param {GEOSSTRtree} tree - the GEOSSTRtree to search
   * @param {GEOSGeometry} geom - the geometry with which the tree should be queried
   * @returns {number} a const pointer to the nearest GEOSGeometry in the tree to 'geom', or NULL in case of exception
   * @alias module:geos
   */
  geos.GEOSSTRtree_nearest = null

  /**
   * Returns the nearest item in the GEOSSTRtree to the supplied item The tree will automatically be constructed if necessary, after which no more items may be added.
   * @param {GEOSSTRtree} tree - the STRtree to search
   * @param {Pointer} item - the item with which the tree should be queried
   * @param {GEOSGeometry} itemEnvelope - a GEOSGeometry having the bounding box of 'item'
   * @param {GEOSDistanceCallback} distancefn - a function that can compute the distance between two items in the STRtree. The function should return zero in case of error, and should store the computed distance to the location pointed to by the distance argument. The computed distance between two items must not exceed the Cartesian distance between their envelopes.
   * @param {Pointer} userdata - optional pointer to arbitrary data; will be passed to distancefn each time it is called.
   * @returns {number} a const pointer to the nearest item in the tree to item, or NULL in case of exception
   * @alias module:geos
   */
  geos.GEOSSTRtree_nearest_generic = null

  /**
   * Returns the nearest item in the GEOSSTRtree to the supplied item The tree will automatically be constructed if necessary, after which no more items may be added.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSSTRtree} tree - the STRtree to search
   * @param {Pointer} item - the item with which the tree should be queried
   * @param {GEOSGeometry} itemEnvelope - a GEOSGeometry having the bounding box of 'item'
   * @param {GEOSDistanceCallback} distancefn - a function that can compute the distance between two items in the STRtree. The function should return zero in case of error, and should store the computed distance to the location pointed to by the distance argument. The computed distance between two items must not exceed the Cartesian distance between their envelopes.
   * @param {Pointer} userdata - optional pointer to arbitrary data; will be passed to distancefn each time it is called.
   * @returns {number} a const pointer to the nearest item in the tree to item, or NULL in case of exception
   * @alias module:geos
   */
  geos.GEOSSTRtree_nearest_generic_r = Module.cwrap('GEOSSTRtree_nearest_generic_r', 'number', ['number', 'number', 'number', 'number', 'number', 'number'])

  /**
   * Returns the nearest item in the GEOSSTRtree to the supplied geometry. All items in the tree MUST be of type GEOSGeometry. If this is not the case, use GEOSSTRtree_nearest_generic() instead. The tree will automatically be constructed if necessary, after which no more items may be added.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSSTRtree} tree - the GEOSSTRtree to search
   * @param {GEOSGeometry} geom - the geometry with which the tree should be queried
   * @returns {number} a const pointer to the nearest GEOSGeometry in the tree to 'geom', or NULL in case of exception
   * @alias module:geos
   */
  geos.GEOSSTRtree_nearest_r = Module.cwrap('GEOSSTRtree_nearest_r', 'number', ['number', 'number', 'number'])

  /**
   * Query a GEOSSTRtree for items intersecting a specified envelope. The tree will automatically be constructed if necessary, after which no more items may be added.
   * @param {GEOSSTRtree} tree - the GEOSSTRtree to search
   * @param {GEOSGeometry} g - a GEOSGeomety from which a query envelope will be extracted
   * @param {GEOSQueryCallback} callback - a function to be executed for each item in the tree whose envelope intersects the envelope of 'g'. The callback function should take two parameters: a void pointer representing the located item in the tree, and a void userdata pointer.
   * @param {Pointer} userdata - an optional pointer to pe passed to callback as an argument
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSSTRtree_query = null

  /**
   * Query a GEOSSTRtree for items intersecting a specified envelope. The tree will automatically be constructed if necessary, after which no more items may be added.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSSTRtree} tree - the GEOSSTRtree to search
   * @param {GEOSGeometry} g - a GEOSGeomety from which a query envelope will be extracted
   * @param {GEOSQueryCallback} callback - a function to be executed for each item in the tree whose envelope intersects the envelope of 'g'. The callback function should take two parameters: a void pointer representing the located item in the tree, and a void userdata pointer.
   * @param {Pointer} userdata - an optional pointer to pe passed to callback as an argument
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSSTRtree_query_r = Module.cwrap('GEOSSTRtree_query_r', 'null', ['number', 'number', 'number', 'number', 'number'])

  /**
   * Removes an item from the GEOSSTRtree The tree will automatically be constructed if necessary, after which no more items may be added.
   * @param {GEOSSTRtree} tree - the STRtree from which to remove an item
   * @param {GEOSGeometry} g - the envelope of the item to remove
   * @param {Pointer} item - the item to remove
   * @returns {number} 0 if the item was not removed; 1 if the item was removed; 2 if an exception occurred
   * @alias module:geos
   */
  geos.GEOSSTRtree_remove = null

  /**
   * Removes an item from the GEOSSTRtree The tree will automatically be constructed if necessary, after which no more items may be added.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSSTRtree} tree - the STRtree from which to remove an item
   * @param {GEOSGeometry} g - the envelope of the item to remove
   * @param {Pointer} item - the item to remove
   * @returns {number} 0 if the item was not removed; 1 if the item was removed; 2 if an exception occurred
   * @alias module:geos
   */
  geos.GEOSSTRtree_remove_r = Module.cwrap('GEOSSTRtree_remove_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Returns the symmetric difference of two geometries A and B: the set of points that fall in A but not within B and the set of points that fall in B but not in A.
   * @param {GEOSGeometry} ga - geometry A
   * @param {GEOSGeometry} gb - geometry B
   * @returns {GEOSGeometry} A newly allocated geometry of the symmetric difference. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSSymDifference = null

  /**
   * Returns the symmetric difference of two geometries A and B: the set of points that fall in A but not within B and the set of points that fall in B but not in A.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - geometry A
   * @param {GEOSGeometry} g2 - geometry B
   * @returns {GEOSGeometry} A newly allocated geometry of the symmetric difference. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSSymDifference_r = Module.cwrap('GEOSSymDifference_r', 'number', ['number', 'number', 'number'])

  /**
   * Returns the symmetric difference of two geometries A and B: the set of points that fall in A but not within B and the set of points that fall in B but not in A. All the vertices of the output geometry must fall on the grid defined by the gridSize, and the output will be a valid geometry.
   * @param {GEOSGeometry} ga - one of the geometries
   * @param {GEOSGeometry} gb - the other geometry
   * @param {number} gridSize - the cell size of the precision grid
   * @returns {GEOSGeometry} A newly allocated geometry of the symmetric difference. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSSymDifferencePrec = null

  /**
   * Returns the symmetric difference of two geometries A and B: the set of points that fall in A but not within B and the set of points that fall in B but not in A. All the vertices of the output geometry must fall on the grid defined by the gridSize, and the output will be a valid geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - one of the geometries
   * @param {GEOSGeometry} g2 - the other geometry
   * @param {number} gridSize - the cell size of the precision grid
   * @returns {GEOSGeometry} A newly allocated geometry of the symmetric difference. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSSymDifferencePrec_r = Module.cwrap('GEOSSymDifferencePrec_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Apply the Douglas/Peucker algorithm to the coordinate sequences of the input geometry. Removes "unnecessary" vertices, vertices that are co-linear within the tolerance distance. Returns a valid output geometry, checking for collapses, ring-intersections, etc and attempting to avoid. More computationally expensive than GEOSSimplify()
   * @param {GEOSGeometry} g - The input geometry
   * @param {number} tolerance - The tolerance to apply. Larger tolerance leads to simpler output.
   * @returns {GEOSGeometry} The simplified geometry Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSTopologyPreserveSimplify = null

  /**
   * Apply the Douglas/Peucker algorithm to the coordinate sequences of the input geometry. Removes "unnecessary" vertices, vertices that are co-linear within the tolerance distance. Returns a valid output geometry, checking for collapses, ring-intersections, etc and attempting to avoid. More computationally expensive than GEOSSimplify()
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry
   * @param {number} tolerance - The tolerance to apply. Larger tolerance leads to simpler output.
   * @returns {GEOSGeometry} The simplified geometry Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSTopologyPreserveSimplify_r = Module.cwrap('GEOSTopologyPreserveSimplify_r', 'number', ['number', 'number', 'number'])

  /**
   * Tests if two geometries share boundaries at one or more points, but do not have interior points in common.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSTouches = null

  /**
   * Tests if two geometries share boundaries at one or more points, but do not have interior points in common.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSTouches_r = Module.cwrap('GEOSTouches_r', 'number', ['number', 'number', 'number'])

  /**
   * Returns the union of all components of a single geometry. Usually used to convert a collection into the smallest set of polygons that cover the same area.
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} A newly allocated geometry of the union. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSUnaryUnion = null

  /**
   * Returns the union of all components of a single geometry. Usually used to convert a collection into the smallest set of polygons that cover the same area.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - The input geometry
   * @returns {GEOSGeometry} A newly allocated geometry of the union. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSUnaryUnion_r = Module.cwrap('GEOSUnaryUnion_r', 'number', ['number', 'number'])

  /**
   * Returns the union of all components of a single geometry. Usually used to convert a collection into the smallest set of polygons that cover the same area. All the vertices of the output geometry must fall on the grid defined by the gridSize, and the output will be a valid geometry.
   * @param {GEOSGeometry} g - input geometry
   * @param {number} gridSize - the cell size of the precision grid
   * @returns {GEOSGeometry} A newly allocated geometry of the union. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSUnaryUnionPrec = null

  /**
   * Returns the union of all components of a single geometry. Usually used to convert a collection into the smallest set of polygons that cover the same area. All the vertices of the output geometry must fall on the grid defined by the gridSize, and the output will be a valid geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g - input geometry
   * @param {number} gridSize - the cell size of the precision grid
   * @returns {GEOSGeometry} A newly allocated geometry of the union. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSUnaryUnionPrec_r = Module.cwrap('GEOSUnaryUnionPrec_r', 'number', ['number', 'number', 'number'])

  /**
   * Returns the union of two geometries A and B: the set of points that fall in A or within B.
   * @param {GEOSGeometry} ga - geometry A
   * @param {GEOSGeometry} gb - geometry B
   * @returns {GEOSGeometry} A newly allocated geometry of the union. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSUnion = null

  /**
   * Returns the union of two geometries A and B: the set of points that fall in A or within B.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - geometry A
   * @param {GEOSGeometry} g2 - geometry B
   * @returns {GEOSGeometry} A newly allocated geometry of the union. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSUnion_r = Module.cwrap('GEOSUnion_r', 'number', ['number', 'number', 'number'])

  /**
   * @param {GEOSGeometry} g -
   * @returns {GEOSGeometry} GEOSGeometry*
   * @deprecated in 3.3.0: use GEOSUnaryUnion() instead
   * @alias module:geos
   */
  geos.GEOSUnionCascaded = null

  /**
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g -
   * @returns {GEOSGeometry} GEOSGeometry*
   * @deprecated in 3.3.0: use GEOSUnaryUnion_r() instead
   * @alias module:geos
   */
  geos.GEOSUnionCascaded_r = Module.cwrap('GEOSUnionCascaded_r', 'number', ['number', 'number'])

  /**
   * Returns the union of two geometries A and B: the set of points that fall in A or within B. All the vertices of the output geometry must fall on the grid defined by the gridSize, and the output will be a valid geometry.
   * @param {GEOSGeometry} ga - one of the geometries
   * @param {GEOSGeometry} gb - the other geometry
   * @param {number} gridSize - the cell size of the precision grid
   * @returns {GEOSGeometry} A newly allocated geometry of the union. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSUnionPrec = null

  /**
   * Returns the union of two geometries A and B: the set of points that fall in A or within B. All the vertices of the output geometry must fall on the grid defined by the gridSize, and the output will be a valid geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - one of the geometries
   * @param {GEOSGeometry} g2 - the other geometry
   * @param {number} gridSize - the cell size of the precision grid
   * @returns {GEOSGeometry} A newly allocated geometry of the union. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSUnionPrec_r = Module.cwrap('GEOSUnionPrec_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Returns the current GEOS version string. eg: "3.10.0" This function does not have a reentrant variant and is available if GEOS_USE_ONLY_R_API is defined.
   * @returns {number} version string
   * @alias module:geos
   */
  geos.GEOSversion = null

  /**
   * Returns the Voronoi polygons or edges of the vertices of the given geometry.
   * @param {GEOSGeometry} g - the input geometry whose vertices will be used as sites.
   * @param {GEOSGeometry} env - snapping tolerance to use for improved robustness. A tolerance of 0.0 specifies that no snapping will take place. This argument can be finicky and is known to cause the algorithm to fail in several cases. If you're using tolerance and getting a failure, try setting it to 0.0.
   * @param {number} tolerance - A value from the GEOSVoronoiFlags enum
   * @param {number} flags - clipping envelope for the returned diagram, automatically determined if env is NULL. The diagram will be clipped to the larger of this envelope or an envelope surrounding the sites.
   * @returns {GEOSGeometry} A newly allocated geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSVoronoiDiagram = null

  /**
   * Returns the Voronoi polygons or edges of the vertices of the given geometry.
   * @param {GEOSContextHandle_t} extHandle -
   * @param {GEOSGeometry} g - the input geometry whose vertices will be used as sites.
   * @param {GEOSGeometry} env - snapping tolerance to use for improved robustness. A tolerance of 0.0 specifies that no snapping will take place. This argument can be finicky and is known to cause the algorithm to fail in several cases. If you're using tolerance and getting a failure, try setting it to 0.0.
   * @param {number} tolerance - A value from the GEOSVoronoiFlags enum
   * @param {number} flags - clipping envelope for the returned diagram, automatically determined if env is NULL. The diagram will be clipped to the larger of this envelope or an envelope surrounding the sites.
   * @returns {GEOSGeometry} A newly allocated geometry. NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy().
   * @alias module:geos
   */
  geos.GEOSVoronoiDiagram_r = Module.cwrap('GEOSVoronoiDiagram_r', 'number', ['number', 'number', 'number', 'number', 'number'])

  /**
   * Tests if geometry g1 is completely within g2, but not wholly contained in the boundary of g2.
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSWithin = null

  /**
   * Tests if geometry g1 is completely within g2, but not wholly contained in the boundary of g2.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSGeometry} g1 - Input geometry
   * @param {GEOSGeometry} g2 - Input geometry
   * @returns {number} 1 on true, 0 on false, 2 on exception
   * @alias module:geos
   */
  geos.GEOSWithin_r = Module.cwrap('GEOSWithin_r', 'number', ['number', 'number', 'number'])

  /**
   * Allocate a new GEOSWKBReader.
   * @returns {GEOSWKBReader} a new reader. Caller must free with GEOSWKBReader_destroy()
   * @alias module:geos
   */
  geos.GEOSWKBReader_create = null

  /**
   * Allocate a new GEOSWKBReader.
   * @param {GEOSContextHandle_t} handle -
   * @returns {GEOSWKBReader} a new reader. Caller must free with GEOSWKBReader_destroy()
   * @alias module:geos
   */
  geos.GEOSWKBReader_create_r = Module.cwrap('GEOSWKBReader_create_r', 'number', ['number'])

  /**
   * Free the memory associated with a GEOSWKBReader.
   * @param {GEOSWKBReader} reader - The reader to destroy.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKBReader_destroy = null

  /**
   * Free the memory associated with a GEOSWKBReader.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKBReader} reader - The reader to destroy.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKBReader_destroy_r = Module.cwrap('GEOSWKBReader_destroy_r', 'null', ['number', 'number'])

  /**
   * Read a geometry from a well-known binary buffer.
   * @param {GEOSWKBReader} reader - A GEOSWKBReader
   * @param {Pointer} wkb - A pointer to the buffer to read from
   * @param {number} size - The number of bytes of data in the buffer
   * @returns {GEOSGeometry} A GEOSGeometry built from the WKB, or NULL on exception.
   * @alias module:geos
   */
  geos.GEOSWKBReader_read = null

  /**
   * Read a geometry from a well-known binary buffer.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKBReader} reader - A GEOSWKBReader
   * @param {Pointer} wkb - A pointer to the buffer to read from
   * @param {number} size - The number of bytes of data in the buffer
   * @returns {GEOSGeometry} A GEOSGeometry built from the WKB, or NULL on exception.
   * @alias module:geos
   */
  geos.GEOSWKBReader_read_r = Module.cwrap('GEOSWKBReader_read_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Read a geometry from a hex encoded well-known binary buffer.
   * @param {GEOSWKBReader} reader - A GEOSWKBReader
   * @param {Pointer} hex - A pointer to the buffer to read from
   * @param {number} size - The number of bytes of data in the buffer
   * @returns {GEOSGeometry} A GEOSGeometry built from the HEX WKB, or NULL on exception.
   * @alias module:geos
   */
  geos.GEOSWKBReader_readHEX = null

  /**
   * Read a geometry from a hex encoded well-known binary buffer.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKBReader} reader - A GEOSWKBReader
   * @param {Pointer} hex - A pointer to the buffer to read from
   * @param {number} size - The number of bytes of data in the buffer
   * @returns {GEOSGeometry} A GEOSGeometry built from the HEX WKB, or NULL on exception.
   * @alias module:geos
   */
  geos.GEOSWKBReader_readHEX_r = Module.cwrap('GEOSWKBReader_readHEX_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Set the reader to automatically repair structural errors in the input (currently just unclosed rings) while reading.
   * @param {GEOSWKBReader} reader - A WKB reader object, caller retains ownership
   * @param {number} doFix - Set to 1 to repair, 0 for no repair (default).
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKBReader_setFixStructure = null

  /**
   * Set the reader to automatically repair structural errors in the input (currently just unclosed rings) while reading.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKBReader} reader - A WKB reader object, caller retains ownership
   * @param {number} doFix - Set to 1 to repair, 0 for no repair (default).
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKBReader_setFixStructure_r = Module.cwrap('GEOSWKBReader_setFixStructure_r', 'null', ['number', 'number', 'number'])

  /**
   * Allocate a new GEOSWKBWriter.
   * @returns {GEOSWKBWriter} a new writer. Caller must free with GEOSWKBWriter_destroy()
   * @alias module:geos
   */
  geos.GEOSWKBWriter_create = null

  /**
   * Allocate a new GEOSWKBWriter.
   * @param {GEOSContextHandle_t} handle -
   * @returns {GEOSWKBWriter} a new writer. Caller must free with GEOSWKBWriter_destroy()
   * @alias module:geos
   */
  geos.GEOSWKBWriter_create_r = Module.cwrap('GEOSWKBWriter_create_r', 'number', ['number'])

  /**
   * Free the memory associated with a GEOSWKBWriter.
   * @param {GEOSWKBWriter} writer - The writer to destroy.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKBWriter_destroy = null

  /**
   * Free the memory associated with a GEOSWKBWriter.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKBWriter} writer - The writer to destroy.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKBWriter_destroy_r = Module.cwrap('GEOSWKBWriter_destroy_r', 'null', ['number', 'number'])

  /**
   * Find whether the writer will use WKB byte order that is big or little endian. The return value is a member of GEOSWKBByteOrders.
   * @param {GEOSWKBWriter} writer - The writer to read byte order from
   * @returns {number} The current byte order
   * @alias module:geos
   */
  geos.GEOSWKBWriter_getByteOrder = null

  /**
   * Find whether the writer will use WKB byte order that is big or little endian. The return value is a member of GEOSWKBByteOrders.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKBWriter} writer - The writer to read byte order from
   * @returns {number} The current byte order
   * @alias module:geos
   */
  geos.GEOSWKBWriter_getByteOrder_r = Module.cwrap('GEOSWKBWriter_getByteOrder_r', 'number', ['number', 'number'])

  /**
   * Find whether the writer will use WKB that is ISO flavor or "extended" flavor. The flavor determines how extra dimensionality is encoded with the type number, and whether SRID can be included in the WKB. ISO flavor does not support SRID embedding. ISO flavor is "more standard" for 3D output. GEOS can read both flavors. The return value is a member of GEOSWKBFlavors.
   * @param {GEOSWKBWriter} writer - The writer to read flavor from
   * @returns {number} The current flavor
   * @alias module:geos
   */
  geos.GEOSWKBWriter_getFlavor = null

  /**
   * Find whether the writer will use WKB that is ISO flavor or "extended" flavor. The flavor determines how extra dimensionality is encoded with the type number, and whether SRID can be included in the WKB. ISO flavor does not support SRID embedding. ISO flavor is "more standard" for 3D output. GEOS can read both flavors. The return value is a member of GEOSWKBFlavors.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKBWriter} writer - The writer to read flavor from
   * @returns {number} The current flavor
   * @alias module:geos
   */
  geos.GEOSWKBWriter_getFlavor_r = Module.cwrap('GEOSWKBWriter_getFlavor_r', 'number', ['number', 'number'])

  /**
   * Read the current SRID embedding value from the writer.
   * @param {GEOSWKBWriter} writer - The writer to check SRID value on
   * @returns {number} char
   * @alias module:geos
   */
  geos.GEOSWKBWriter_getIncludeSRID = null

  /**
   * Read the current SRID embedding value from the writer.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKBWriter} writer - The writer to check SRID value on
   * @returns {number} char
   * @alias module:geos
   */
  geos.GEOSWKBWriter_getIncludeSRID_r = Module.cwrap('GEOSWKBWriter_getIncludeSRID_r', 'number', ['number', 'number'])

  /**
   * Read the current output dimension of the writer. Either 2, 3, or 4 dimensions. Return current number of dimensions.
   * @param {GEOSWKBWriter} writer - The writer to read from.
   * @returns {number} Number of dimensions (2, 3, or 4)
   * @alias module:geos
   */
  geos.GEOSWKBWriter_getOutputDimension = null

  /**
   * Read the current output dimension of the writer. Either 2, 3, or 4 dimensions. Return current number of dimensions.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKBWriter} writer - The writer to read from.
   * @returns {number} Number of dimensions (2, 3, or 4)
   * @alias module:geos
   */
  geos.GEOSWKBWriter_getOutputDimension_r = Module.cwrap('GEOSWKBWriter_getOutputDimension_r', 'number', ['number', 'number'])

  /**
   * Set the output byte order of the writer, using a value from GEOSWKBByteOrders enum.
   * @param {GEOSWKBWriter} writer - The writer to set byte order on
   * @param {number} byteOrder - Desired byte order
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKBWriter_setByteOrder = null

  /**
   * Set the output byte order of the writer, using a value from GEOSWKBByteOrders enum.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKBWriter} writer - The writer to set byte order on
   * @param {number} byteOrder - Desired byte order
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKBWriter_setByteOrder_r = Module.cwrap('GEOSWKBWriter_setByteOrder_r', 'null', ['number', 'number', 'number'])

  /**
   * Set the output flavor of the writer, using a value from GEOSWKBFlavors enum.
   * @param {GEOSWKBWriter} writer - The writer to set flavor on
   * @param {number} flavor - Desired flavor
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKBWriter_setFlavor = null

  /**
   * Set the output flavor of the writer, using a value from GEOSWKBFlavors enum.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKBWriter} writer - The writer to set flavor on
   * @param {number} flavor - Desired flavor
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKBWriter_setFlavor_r = Module.cwrap('GEOSWKBWriter_setFlavor_r', 'null', ['number', 'number', 'number'])

  /**
   * Specify whether SRID values should be output in WKB. Many WKB readers do not support SRID values, use with caution.
   * @param {GEOSWKBWriter} writer - The writer to set SRID output on
   * @param {number} writeSRID - Set to 1 to include SRID, 0 otherwise
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKBWriter_setIncludeSRID = null

  /**
   * Specify whether SRID values should be output in WKB. Many WKB readers do not support SRID values, use with caution.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKBWriter} writer - The writer to set SRID output on
   * @param {number} writeSRID - Set to 1 to include SRID, 0 otherwise
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKBWriter_setIncludeSRID_r = Module.cwrap('GEOSWKBWriter_setIncludeSRID_r', 'null', ['number', 'number', 'number'])

  /**
   * Set the output dimensionality of the writer. Either 2, 3, or 4 dimensions. Default since GEOS 3.12 is 4.
   * @param {GEOSWKBWriter} writer - The writer to read from.
   * @param {number} newDimension - The dimensionality desired
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKBWriter_setOutputDimension = null

  /**
   * Set the output dimensionality of the writer. Either 2, 3, or 4 dimensions. Default since GEOS 3.12 is 4.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKBWriter} writer - The writer to read from.
   * @param {number} newDimension - The dimensionality desired
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKBWriter_setOutputDimension_r = Module.cwrap('GEOSWKBWriter_setOutputDimension_r', 'null', ['number', 'number', 'number'])

  /**
   * Write out the WKB representation of a geometry.
   * @param {GEOSWKBWriter} writer - The GEOSWKBWriter controlling the writing.
   * @param {GEOSGeometry} g - Geometry to convert to WKB
   * @param {NumberPointer} size - Pointer to write the size of the final output WKB to
   * @returns {number} The WKB representation. Caller must free with GEOSFree()
   * @alias module:geos
   */
  geos.GEOSWKBWriter_write = null

  /**
   * Write out the WKB representation of a geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKBWriter} writer - The GEOSWKBWriter controlling the writing.
   * @param {GEOSGeometry} g - Geometry to convert to WKB
   * @param {NumberPointer} size - Pointer to write the size of the final output WKB to
   * @returns {number} The WKB representation. Caller must free with GEOSFree()
   * @alias module:geos
   */
  geos.GEOSWKBWriter_write_r = Module.cwrap('GEOSWKBWriter_write_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Write out the hex WKB representation of a geometry.
   * @param {GEOSWKBWriter} writer - The GEOSWKBWriter controlling the writing.
   * @param {GEOSGeometry} g - Geometry to convert to WKB
   * @param {NumberPointer} size - Pointer to write the size of the final output WKB to
   * @returns {number} The HEX WKB representation. Caller must free with GEOSFree()
   * @alias module:geos
   */
  geos.GEOSWKBWriter_writeHEX = null

  /**
   * Write out the hex WKB representation of a geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKBWriter} writer - The GEOSWKBWriter controlling the writing.
   * @param {GEOSGeometry} g - Geometry to convert to WKB
   * @param {NumberPointer} size - Pointer to write the size of the final output WKB to
   * @returns {number} The HEX WKB representation. Caller must free with GEOSFree()
   * @alias module:geos
   */
  geos.GEOSWKBWriter_writeHEX_r = Module.cwrap('GEOSWKBWriter_writeHEX_r', 'number', ['number', 'number', 'number', 'number'])

  /**
   * Allocate a new GEOSWKTReader.
   * @returns {GEOSWKTReader} a new reader. Caller must free with GEOSWKTReader_destroy()
   * @alias module:geos
   */
  geos.GEOSWKTReader_create = null

  /**
   * Allocate a new GEOSWKTReader.
   * @param {GEOSContextHandle_t} handle -
   * @returns {GEOSWKTReader} a new reader. Caller must free with GEOSWKTReader_destroy()
   * @alias module:geos
   */
  geos.GEOSWKTReader_create_r = Module.cwrap('GEOSWKTReader_create_r', 'number', ['number'])

  /**
   * Free the memory associated with a GEOSWKTReader.
   * @param {GEOSWKTReader} reader - The reader to destroy.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKTReader_destroy = null

  /**
   * Free the memory associated with a GEOSWKTReader.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKTReader} reader - The reader to destroy.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKTReader_destroy_r = Module.cwrap('GEOSWKTReader_destroy_r', 'null', ['number', 'number'])

  /**
   * Use a reader to parse the well-known text representation of a geometry, and return an allocated geometry.
   * @param {GEOSWKTReader} reader - A WKT reader object, caller retains ownership
   * @param {StringPointer} wkt - The WKT string to parse, caller retains ownership
   * @returns {GEOSGeometry} A GEOSGeometry, caller to free with GEOSGeom_destroy())
   * @alias module:geos
   */
  geos.GEOSWKTReader_read = null

  /**
   * Use a reader to parse the well-known text representation of a geometry, and return an allocated geometry.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKTReader} reader - A WKT reader object, caller retains ownership
   * @param {StringPointer} wkt - The WKT string to parse, caller retains ownership
   * @returns {GEOSGeometry} A GEOSGeometry, caller to free with GEOSGeom_destroy())
   * @alias module:geos
   */
  geos.GEOSWKTReader_read_r = Module.cwrap('GEOSWKTReader_read_r', 'number', ['number', 'number', 'number'])

  /**
   * Set the reader to automatically repair structural errors in the input (currently just unclosed rings) while reading.
   * @param {GEOSWKTReader} reader - A WKT reader object, caller retains ownership
   * @param {number} doFix - Set to 1 to repair, 0 for no repair (default).
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKTReader_setFixStructure = null

  /**
   * Set the reader to automatically repair structural errors in the input (currently just unclosed rings) while reading.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKTReader} reader - A WKT reader object, caller retains ownership
   * @param {number} doFix - Set to 1 to repair, 0 for no repair (default).
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKTReader_setFixStructure_r = Module.cwrap('GEOSWKTReader_setFixStructure_r', 'null', ['number', 'number', 'number'])

  /**
   * Allocate a new GEOSWKTWriter.
   * @returns {GEOSWKTWriter} a new writer. Caller must free with GEOSWKTWriter_destroy()
   * @alias module:geos
   */
  geos.GEOSWKTWriter_create = null

  /**
   * Allocate a new GEOSWKTReader.
   * @param {GEOSContextHandle_t} handle -
   * @returns {GEOSWKTWriter} a new reader. Caller must free with GEOSWKTReader_destroy()
   * @alias module:geos
   */
  geos.GEOSWKTWriter_create_r = Module.cwrap('GEOSWKTWriter_create_r', 'number', ['number'])

  /**
   * Free the memory associated with a GEOSWKTWriter.
   * @param {GEOSWKTWriter} writer - The writer to destroy.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKTWriter_destroy = null

  /**
   * Free the memory associated with a GEOSWKTWriter.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKTWriter} writer - The writer to destroy.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKTWriter_destroy_r = Module.cwrap('GEOSWKTWriter_destroy_r', 'null', ['number', 'number'])

  /**
   * Reads the current output dimension from a GEOSWKTWriter.
   * @param {GEOSWKTWriter} writer - A GEOSWKTWriter.
   * @returns {number} The current dimension.
   * @alias module:geos
   */
  geos.GEOSWKTWriter_getOutputDimension = null

  /**
   * Reads the current output dimension from a GEOSWKTWriter.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKTWriter} writer - A GEOSWKTWriter.
   * @returns {number} The current dimension.
   * @alias module:geos
   */
  geos.GEOSWKTWriter_getOutputDimension_r = Module.cwrap('GEOSWKTWriter_getOutputDimension_r', 'number', ['number', 'number'])

  /**
   * Sets the format for 3D outputs. The "old 3D" format does not include a Z dimension tag, e.g. "POINT (1 2 3)", except for XYM, e.g. "POINT M (1 2 3)". Geometries with XYZM coordinates do not add any dimensionality tags, e.g. "POINT (1 2 3 4)".
   * @param {GEOSWKTWriter} writer - A GEOSWKTWriter.
   * @param {number} useOld3D - True to use the old format, false is the default.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKTWriter_setOld3D = null

  /**
   * Sets the format for 3D outputs. The "old 3D" format does not include a Z dimension tag, e.g. "POINT (1 2 3)", except for XYM, e.g. "POINT M (1 2 3)". Geometries with XYZM coordinates do not add any dimensionality tags, e.g. "POINT (1 2 3 4)".
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKTWriter} writer - A GEOSWKTWriter.
   * @param {number} useOld3D - True to use the old format, false is the default.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKTWriter_setOld3D_r = Module.cwrap('GEOSWKTWriter_setOld3D_r', 'null', ['number', 'number', 'number'])

  /**
   * Set the output dimensionality of the writer. Either 2, 3, or 4 dimensions. Default since GEOS 3.12 is 4.
   * @param {GEOSWKTWriter} writer - A GEOSWKTWriter.
   * @param {number} dim - The dimensionality desired.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKTWriter_setOutputDimension = null

  /**
   * Set the output dimensionality of the writer. Either 2, 3, or 4 dimensions. Default since GEOS 3.12 is 4.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKTWriter} writer - A GEOSWKTWriter.
   * @param {number} dim - The dimensionality desired.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKTWriter_setOutputDimension_r = Module.cwrap('GEOSWKTWriter_setOutputDimension_r', 'null', ['number', 'number', 'number'])

  /**
   * Sets the number places after the decimal to output in WKT.
   * @param {GEOSWKTWriter} writer - A GEOSWKTWriter.
   * @param {number} precision - The desired precision, default 16.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKTWriter_setRoundingPrecision = null

  /**
   * Sets the number places after the decimal to output in WKT.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKTWriter} writer - A GEOSWKTWriter.
   * @param {number} precision - The desired precision, default 16.
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKTWriter_setRoundingPrecision_r = Module.cwrap('GEOSWKTWriter_setRoundingPrecision_r', 'null', ['number', 'number', 'number'])

  /**
   * Sets the number trimming option on a GEOSWKTWriter. With trim set to 1, the writer will strip trailing 0's from the output coordinates. With 1 (trimming enabled), big and small absolute coordinates will use scientific notation, otherwise positional notation is used; see GEOS_printDouble for details. With 0 (trimming disabled), all coordinates will be padded with 0's out to the rounding precision. Default since GEOS 3.12 is with trim set to 1 for 'on'.
   * @param {GEOSWKTWriter} writer - A GEOSWKTWriter.
   * @param {number} trim - The trimming behaviour to set, 1 for 'on', 0 for 'off'
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKTWriter_setTrim = null

  /**
   * Sets the number trimming option on a GEOSWKTWriter. With trim set to 1, the writer will strip trailing 0's from the output coordinates. With 1 (trimming enabled), big and small absolute coordinates will use scientific notation, otherwise positional notation is used; see GEOS_printDouble for details. With 0 (trimming disabled), all coordinates will be padded with 0's out to the rounding precision. Default since GEOS 3.12 is with trim set to 1 for 'on'.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKTWriter} writer - A GEOSWKTWriter.
   * @param {number} trim - The trimming behaviour to set, 1 for 'on', 0 for 'off'
   * @returns {null} void
   * @alias module:geos
   */
  geos.GEOSWKTWriter_setTrim_r = Module.cwrap('GEOSWKTWriter_setTrim_r', 'null', ['number', 'number', 'number'])

  /**
   * Writes out the well-known text representation of a geometry, using the trim, rounding and dimension settings of the writer.
   * @param {GEOSWKTWriter} writer - A GEOSWKTWriter.
   * @param {GEOSGeometry} g - Input geometry
   * @returns {StringPointer} A newly allocated string containing the WKT output or NULL on exception. Caller must free with GEOSFree()
   * @alias module:geos
   */
  geos.GEOSWKTWriter_write = null

  /**
   * Writes out the well-known text representation of a geometry, using the trim, rounding and dimension settings of the writer.
   * @param {GEOSContextHandle_t} handle -
   * @param {GEOSWKTWriter} writer - A GEOSWKTWriter.
   * @param {GEOSGeometry} g - Input geometry
   * @returns {StringPointer} A newly allocated string containing the WKT output or NULL on exception. Caller must free with GEOSFree()
   * @alias module:geos
   */
  geos.GEOSWKTWriter_write_r = Module.cwrap('GEOSWKTWriter_write_r', 'number', ['number', 'number', 'number'])

  return geos
};
